
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1. First-order derivative and slicing &#8212; Solving Partial Differential Equations - MOOC</title>
    
  <link rel="stylesheet" href="../../../_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mycss.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="2. Higher order derivatives, functions and matrix formulation" href="03_02_HigherOrderDerivative_and_Functions.html" />
    <link rel="prev" title="2. Runge-Kutta methods" href="../02_TimeIntegration/02_02_RungeKutta.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../../index.html">
  
  <img src="../../../_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Solving Partial Differential Equations - MOOC</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../01_Introduction/01_00_Preface.html">
   Numerical methods for partial differential equations
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../01_Introduction/01_01_ToolkitSetup.html">
   1. Toolkit Setup
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../01_Introduction/01_02_TaylorExpansion.html">
   2. Approximations and Taylor expansion
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Time integration
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../02_TimeIntegration/02_01_EulerMethod.html">
   1. Euler methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../02_TimeIntegration/02_02_RungeKutta.html">
   2. Runge-Kutta methods
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Finite differences
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   1. First-order derivative and slicing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="03_02_HigherOrderDerivative_and_Functions.html">
   2. Higher order derivatives, functions and matrix formulation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="03_03_BoundaryValueProblems.html">
   3. Boundary value problems
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Partial differential equations
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../04_PartialDifferentialEquations/04_01_Advection.html">
   1. The first-order wave equation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../04_PartialDifferentialEquations/04_02_StabilityAnalysis.html">
   2. Matrix and modified wavenumber stability analysis
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../04_PartialDifferentialEquations/04_03_Diffusion_Explicit.html">
   3. One dimensional heat equation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../04_PartialDifferentialEquations/04_04_Diffusion_Implicit.html">
   4. One dimensional heat equation: implicit methods
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Iterative methods
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../05_IterativeMethods/05_01_Iteration_and_2D.html">
   1. Iteration methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../05_IterativeMethods/05_02_Conjugate_Gradient.html">
   2. The conjugate gradient method
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../05_IterativeMethods/05_03_Boosting_Python.html">
   3. Boosting Python
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="../../../_sources/solving_pde_mooc/notebooks/03_FiniteDifferences/03_01_FirstOrderDerivative_and_Slicing.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../../_sources/solving_pde_mooc/notebooks/03_FiniteDifferences/03_01_FirstOrderDerivative_and_Slicing.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/aquaULB/solving_pde_mooc"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        
        
    </div>
</div>


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   1.1. Introduction
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#first-order-derivative">
   1.2. First-order derivative
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#python-slicing">
   1.3. Python slicing
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#motivation-and-syntax">
     1.3.1. Motivation and syntax
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#referenced-or-copied">
     1.3.2. Referenced or copied?
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#one-sided-finite-differences">
   1.4. One-sided finite differences
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#summary">
   1.5. Summary
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="first-order-derivative-and-slicing">
<h1><span class="section-number">1. </span>First-order derivative and slicing<a class="headerlink" href="#first-order-derivative-and-slicing" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2><span class="section-number">1.1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>For convenience, we start with importing some modules needed below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="o">%</span><span class="k">matplotlib</span> inline

<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;../styles/mainstyle.use&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In this part of the course we describe how to compute numerically derivatives of functions such as,</p>
<div class="math notranslate nohighlight" id="equation-eq-testfunc">
<span class="eqno">(22)<a class="headerlink" href="#equation-eq-testfunc" title="Permalink to this equation">¶</a></span>\[f(x)=e^x \sin(3\pi x)\]</div>
<p>There are several conceptually different ways to do this. Following the same approach as for time integration, we can rely on Taylor’s theorem to use the value of <span class="math notranslate nohighlight">\(f(x)\)</span> at some neighboring points of <span class="math notranslate nohighlight">\(x\)</span>. This approach relies on what are known as finite differences. Another way to compute derivatives relies on decomposing the function <span class="math notranslate nohighlight">\(f(x)\)</span> on a basis of functions <span class="math notranslate nohighlight">\(T_k(x)\)</span> and computing the derivatives of <span class="math notranslate nohighlight">\(f(x)\)</span> from the known derivatives of <span class="math notranslate nohighlight">\(T_k(x)\)</span>. This method is known as the spectral method and will be described later on in the course.</p>
<p>Let <span class="math notranslate nohighlight">\(x\)</span> be the continuous variable defined in the interval <span class="math notranslate nohighlight">\(x\in[x_0,x_n]\)</span>. In any numerical problem, we have to limit the number of points at which we store the values of <span class="math notranslate nohighlight">\(f(x)\)</span> because the random access memory (RAM) of our computers is limited. We therefore need to introduce an approximation of our continuous interval - the numerical grid. It is a set of grid points at which we evaluate all physical quantities.</p>
<p>For simplicity consider a uniform grid in which the <span class="math notranslate nohighlight">\(n+1\)</span> grid points are evenly distributed. Therefore the coordinates of the grid points are:</p>
<div class="math notranslate nohighlight">
\[ x_i = i \Delta x, \; \; 0\leq i \leq n\]</div>
<p>with the endpoints of the grid located respectively at <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x_n\)</span>.</p>
<p>We will refer to the continuous variable defined in <span class="math notranslate nohighlight">\([x_0,x_n]\)</span> by <span class="math notranslate nohighlight">\(x\)</span>, and to its discrete representation by <span class="math notranslate nohighlight">\(x_i\)</span>. <span class="math notranslate nohighlight">\(x_i\)</span> is called a <em>grid point</em> or sometimes a <em>grid node</em>. The value of some function <span class="math notranslate nohighlight">\(f(x)\)</span> at the grid point <span class="math notranslate nohighlight">\(x_i\)</span> is then denoted as <span class="math notranslate nohighlight">\(f_i\)</span>.</p>
<p>Using these notations, the approximation of a derivative through a finite-difference expression is generically given by:</p>
<div class="math notranslate nohighlight" id="equation-eq-diffgeneric">
<span class="eqno">(23)<a class="headerlink" href="#equation-eq-diffgeneric" title="Permalink to this equation">¶</a></span>\[f^{(k)}_i = \frac{1}{(\Delta x)^k}\sum_{j\in\mathcal{J}}c_j f_{i+j},\]</div>
<p>where <span class="math notranslate nohighlight">\(k\)</span> represents the order of derivative, <span class="math notranslate nohighlight">\(\mathcal{J}\)</span> is called the <em>stencil</em> - the group of points used to build the finite-difference approximation - and <span class="math notranslate nohighlight">\(c_j\)</span> is the finite-difference coefficient defined at the stencil point of index <span class="math notranslate nohighlight">\(j\)</span>.</p>
</div>
<div class="section" id="first-order-derivative">
<h2><span class="section-number">1.2. </span>First-order derivative<a class="headerlink" href="#first-order-derivative" title="Permalink to this headline">¶</a></h2>
<p>As an example of how the finite-difference approximation for a derivative of a given order can be derived, let us consider the first-order derivative of <span class="math notranslate nohighlight">\(f(x)\)</span>. According to Taylor’s theorem, we can approximate <span class="math notranslate nohighlight">\(f(x+\Delta x)\)</span> as follows:</p>
<div class="math notranslate nohighlight" id="equation-taylorser">
<span class="eqno">(24)<a class="headerlink" href="#equation-taylorser" title="Permalink to this equation">¶</a></span>\[f(x+\Delta x)= f(x)+f'(x)\Delta x+O(\Delta x^2).\]</div>
<p>Expression <a class="reference internal" href="#equation-taylorser">(24)</a> is exact and allows us to get the following expression for the first-order derivative of <span class="math notranslate nohighlight">\(f\)</span> at point <span class="math notranslate nohighlight">\(x\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq-forwardtaylordiff1">
<span class="eqno">(25)<a class="headerlink" href="#equation-eq-forwardtaylordiff1" title="Permalink to this equation">¶</a></span>\[f'(x) = \frac{f(x+\Delta x) - f(x)}{\Delta x}+O(\Delta x)\]</div>
<p>This expression is the usual left derivative of <span class="math notranslate nohighlight">\(f(x)\)</span>.</p>
<p>To approximate <a class="reference internal" href="#equation-eq-forwardtaylordiff1">(25)</a> on the grid <span class="math notranslate nohighlight">\(x_0, x_1,\dots, x_i,\dots x_{n-1}, x_n\)</span>, we define the following first-order accurate approximation of <span class="math notranslate nohighlight">\(f'\)</span> at <span class="math notranslate nohighlight">\(x_i\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq-forwardnodal">
<span class="eqno">(26)<a class="headerlink" href="#equation-eq-forwardnodal" title="Permalink to this equation">¶</a></span>\[f^{' \rm f}_i = \frac{f_{i+1} - f_i}{\Delta x},\;\; \hbox{forward finite difference}.\]</div>
<p>The stencil for this expression is given by the sequence <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>, where <code class="docutils literal notranslate"><span class="pre">0</span></code> stands for the point at which the derivative is evaluated, and the corresponding finite-difference coefficients are <code class="docutils literal notranslate"><span class="pre">[-1,</span> <span class="pre">1]</span></code> (see <a class="reference internal" href="#equation-eq-diffgeneric">(23)</a>).</p>
<p>In the following figure we illustrate the stencil and mark in red the points involved in the computation:</p>
<a class="reference internal image-reference" href="../../../_images/forwardDiff1.png"><img alt="../../../_images/forwardDiff1.png" src="../../../_images/forwardDiff1.png" style="width: 600px;" /></a>
<p>Above the stencil, we display the quantity computed, and below the stencil we display the quantities involved in its computations.</p>
<p>It is important to highlight that the <em>enumeration of a stencil has nothing to do with the enumeration of the grid points</em>. The enumeration of grid points usually starts at one of the grid boundaries (<span class="math notranslate nohighlight">\(x_0\)</span> in our cases) and ends at another boundary. The enumeration of a stencil is characteristic of each particular approximation. The stencil point labeled <span class="math notranslate nohighlight">\(0\)</span> corresponds to the grid point at which the derivative is being approximated. The stencil indices then decrease to the left of this point and increase to its right. This is why in the above example the stencil is <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>.</p>
<p>In the above stencil, we use two grid points - <span class="math notranslate nohighlight">\(x_i\)</span> and <span class="math notranslate nohighlight">\(x_{i+1}\)</span> - to obtain a first-order accurate expression for the first-order derivative at <span class="math notranslate nohighlight">\(x_i\)</span>. It is obvious that the forward finite difference formula <a class="reference internal" href="#equation-eq-forwardnodal">(26)</a> cannot be used at the right boundary node <span class="math notranslate nohighlight">\(x_n\)</span>. In section <a class="reference external" href="#One-sided-finite-differences">One-sided finite differences</a>, we discuss how the boundary nodes can be handled when the derivatives are being evaluated using finite differences.</p>
<p>Let us now define the backward finite-differences scheme in an identical manner. As Taylor’s theorem is valid for <span class="math notranslate nohighlight">\(x\)</span> in the interval <span class="math notranslate nohighlight">\(a &lt; x-\Delta x \le x \le x+\Delta x &lt; b\)</span>, we can approximate <span class="math notranslate nohighlight">\(f(x-\Delta x)\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[f(x-\Delta x) \approx f(x) - f'(x)\Delta x. \]</div>
<p>We can then define the first-order accurate backward finite-differences formula for the first-order derivative of <span class="math notranslate nohighlight">\(f(x)\)</span> at <span class="math notranslate nohighlight">\(x_i\)</span> as:</p>
<div class="math notranslate nohighlight" id="equation-eq-backwardnodal">
<span class="eqno">(27)<a class="headerlink" href="#equation-eq-backwardnodal" title="Permalink to this equation">¶</a></span>\[f^{'\rm b}_i = \frac{f_i - f_{i-1}}{\Delta x}, \;\; \hbox{backward finite difference}. \]</div>
<p>It is based on the right derivative <span class="math notranslate nohighlight">\(f'(x)\)</span>. Highlighting in red the stencil points used to build expression <a class="reference internal" href="#equation-eq-backwardnodal">(27)</a>, we have:</p>
<a class="reference internal image-reference" href="../../../_images/backwardDiff1.png"><img alt="../../../_images/backwardDiff1.png" src="../../../_images/backwardDiff1.png" style="width: 600px;" /></a>
<p>As the forward finite-difference approximation cannot be used at the right boundary node <span class="math notranslate nohighlight">\(x_n\)</span>, the backward finite-difference approximation cannot be used at the left boundary node <span class="math notranslate nohighlight">\(x_0\)</span>. We also note that <span class="math notranslate nohighlight">\(f^{'\rm b}_{i+1} = f^{'\rm f}_i\)</span>.</p>
<p>Let us now derive a higher-order accurate approximation for <span class="math notranslate nohighlight">\(f'(x)\)</span>. Resorting again to Taylor’s theorem we write:</p>
<div class="math notranslate nohighlight">
\[\begin{split}&amp; f(x+\Delta x) \approx f(x)+f'(x)\Delta x+\frac12 f''(x)\Delta x^2 \\
&amp; f(x-\Delta x) \approx f(x)-f'(x)\Delta x+\frac12 f''(x)\Delta x^2.\end{split}\]</div>
<p>We substract equations both equations and get:</p>
<div class="math notranslate nohighlight" id="equation-eq-centeredtaylordiff">
<span class="eqno">(28)<a class="headerlink" href="#equation-eq-centeredtaylordiff" title="Permalink to this equation">¶</a></span>\[f'(x) = \frac{f(x+\Delta x) - f(x-\Delta x)}{2\Delta x}+O(\Delta x^2),\]</div>
<p>which leads us to the second-order accurate approximation of <span class="math notranslate nohighlight">\(f'(x)\)</span> at <span class="math notranslate nohighlight">\(x_i\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq-centereddiff">
<span class="eqno">(29)<a class="headerlink" href="#equation-eq-centereddiff" title="Permalink to this equation">¶</a></span>\[f^{' \rm c}_i = \frac{f_{i+1} - f_{i-1}}{2\Delta x},\;\; \hbox{centered finite difference}.\]</div>
<p>This expression is called the centered finite difference first-order derivative and its stencil looks like this:</p>
<a class="reference internal image-reference" href="../../../_images/centeredDiff1.png"><img alt="../../../_images/centeredDiff1.png" src="../../../_images/centeredDiff1.png" style="width: 600px;" /></a>
<p>Using just two grid points, it’s not possible to achieve an accuracy of higher order than <span class="math notranslate nohighlight">\(2\)</span>. The centered finite-difference scheme cannot be used both at the left or right boundary nodes of the grid.</p>
<p>Let us check that our formulas are correct. We first create a fine grid to accurately represent the function <a class="reference internal" href="#equation-eq-testfunc">(22)</a> and its derivative in the interval <span class="math notranslate nohighlight">\(x\in [0, \pi]\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>       <span class="c1"># 3.14...</span>
<span class="n">nx</span> <span class="o">=</span> <span class="mi">200</span>         <span class="c1"># number of grid points (fine grid)</span>
<span class="n">lx</span> <span class="o">=</span> <span class="n">pi</span>          <span class="c1"># length of the interval</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">lx</span> <span class="o">/</span> <span class="p">(</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># grid spacing</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lx</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>   <span class="c1"># coordinates in the fine grid</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="c1"># function in the fine grid</span>

<span class="c1"># Let us build a numpy array for the exact repre-</span>
<span class="c1"># sentation of the first-order derivative of f(x).</span>
<span class="n">dfdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>We have built a numpy array for the exact expression of the first-order derivative of <span class="math notranslate nohighlight">\(f(x)\)</span>. But what if we worked with a complicated function or required expressions for higher-order derivatives? It is useful to keep in mind that there is Python package just for that - for symbolic computations - <a class="reference external" href="https://docs.sympy.org/latest/index.html">SymPy</a>. We won’t get into details and leave it to you to explore SymPy. Note that SymPy is not part of the basic distribution of Anaconda, you would have to install it.</p>
<p>Sympy supports <a class="reference external" href="https://docs.sympy.org/latest/tutorial/calculus.html">basic symbolic calculus</a>, and provides <a class="reference external" href="https://docs.sympy.org/latest/modules/utilities/lambdify.html?highlight=lambdify">tools</a> to transform symbolic data to numerical representation.</p>
<p>To experiment with our finite-difference approximations, we build a coarse grid with <span class="math notranslate nohighlight">\(80\)</span> points, and evaluate the derivative:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We don&#39;t care about overwriting grid variables,</span>
<span class="c1"># as we are not using them further than for con-</span>
<span class="c1"># struction of x and f(x) arrays.</span>
<span class="n">nx</span> <span class="o">=</span> <span class="mi">80</span>          <span class="c1"># number of grid points (coarse grid)</span>
<span class="n">lx</span> <span class="o">=</span> <span class="n">pi</span>          <span class="c1"># length of interval</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">lx</span> <span class="o">/</span> <span class="p">(</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># grid spacing</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lx</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>       <span class="c1"># coordinates of the coarse grid points</span>
<span class="n">f_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x_c</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x_c</span><span class="p">)</span> <span class="c1"># function on the coarse grid</span>

<span class="c1"># We create containers for the forward, backward</span>
<span class="c1"># and centered finite difference points.</span>
<span class="n">df_forward</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
<span class="n">df_backward</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
<span class="n">df_centered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>

<span class="c1"># We fill arrays in the Python loops, so that</span>
<span class="c1"># you can explicitely see what grid nodes have</span>
<span class="c1"># been taken into account.</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># last grid point is omitted</span>
    <span class="n">df_forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_c</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f_c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx</span>
    
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="p">):</span> <span class="c1"># first grid point is omitted</span>
    <span class="n">df_backward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">f_c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># first and last grid points are omitted</span>
    <span class="n">df_centered</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_c</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f_c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let us now plot the forward, backward and centered finite-difference approximations of the first-order derivative of <span class="math notranslate nohighlight">\(f(x)\)</span> against the curve obtained with the exact expression:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">tight_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Forward, backward and centered finite differences vs exact derivative&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">ax</span><span class="p">:</span>
    <span class="n">axis</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="n">axis</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">)</span>
    <span class="n">axis</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;f&#39;&quot;</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dfdx</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_c</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">df_forward</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;^g&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dfdx</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_c</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">nx</span><span class="p">],</span> <span class="n">df_backward</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span> <span class="n">nx</span><span class="p">],</span> <span class="s1">&#39;^m&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dfdx</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_c</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">df_centered</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;^c&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/03_01_FirstOrderDerivative_and_Slicing_10_0.png" src="../../../_images/03_01_FirstOrderDerivative_and_Slicing_10_0.png" />
</div>
</div>
<p>What do you think about the agreement? What happens when you increase the number of points in the coarse grid?</p>
<p>In the above cell, we have used the slicing of numpy arrays to extract the relevant entries from our arrays. For example, for the forward finite difference, the expression is not defined at the last grid point. Therefore, the relevant grid coordinates are not the complete <code class="docutils literal notranslate"><span class="pre">x_c</span></code> array but the <em>slice</em> <code class="docutils literal notranslate"><span class="pre">x_c[0:nx-1]</span></code>. For the centered finite differences we must exclude the first and last grid points. The appropriate coordinate array slice is then <code class="docutils literal notranslate"><span class="pre">x_c[1:nx-1]</span></code>. The notions of slicing of Python sequences are described in much more detail in the next section.</p>
</div>
<div class="section" id="python-slicing">
<h2><span class="section-number">1.3. </span>Python slicing<a class="headerlink" href="#python-slicing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="motivation-and-syntax">
<h3><span class="section-number">1.3.1. </span>Motivation and syntax<a class="headerlink" href="#motivation-and-syntax" title="Permalink to this headline">¶</a></h3>
<p>We already mentioned a powerful tool of Python: negative indexing. When the programmer tries to access elements of the sequence by referring to a negative index, the enumeration of the elements starts from the tail of the sequence. Let’s say we have a Python list,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;first&#39;</span><span class="p">,</span>
    <span class="s1">&#39;second&#39;</span><span class="p">,</span>
    <span class="s1">&#39;third&#39;</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>and we want to iterate through its elements starting from <code class="docutils literal notranslate"><span class="pre">a[2]</span></code> to <code class="docutils literal notranslate"><span class="pre">a[0]</span></code>. It is a valid and even preferrable approach to do it using the negative indexing:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;index: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, value: </span><span class="si">{</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>index: -1, value: third.
index: -2, value: second.
index: -3, value: first.
</pre></div>
</div>
</div>
</div>
<p>Now that we are fully equipped in terms of knowledge about Python indexing, let’s proceed to the Python slicing. Python slicing provides simple access to subsequences in Python sequences and spares programmers the necessity to loop explicitly, as we would do in C++, for example. Moreover, Python slicing <a class="reference external" href="https://github.com/python/cpython/blob/master/Objects/sliceobject.c">is implemented in C and precompiled</a>, so, it’s considerably faster than the corresponding code implemented with a Python loop.</p>
<p>The syntax for Python slicing is the following <code class="docutils literal notranslate"><span class="pre">sequence[i:j:k]</span></code>. <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> are respectively the start and the stop indices, while <code class="docutils literal notranslate"><span class="pre">k</span></code> is the step. Therefore, the slice is built from the sequence elements with indices: <span class="math notranslate nohighlight">\(i, i+k, i+2k, \dots, i+nk &lt; j\)</span>. <strong>Always remember that <code class="docutils literal notranslate"><span class="pre">sequence[i]</span></code> is included in the slice while <code class="docutils literal notranslate"><span class="pre">sequence[j]</span></code> is not.</strong></p>
<p>Below, we will use the notation <code class="docutils literal notranslate"><span class="pre">sequence[start:stop:step]</span></code> to be explicit about the meaning of the indices.</p>
<p>Consider the following demo. First, we create large Python list.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">large_sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">5</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>Suppose we want to extract the sublist with the first element equal to <code class="docutils literal notranslate"><span class="pre">large_sequence[5]</span></code> and the last element equal to <code class="docutils literal notranslate"><span class="pre">large_sequence[99994]</span></code>. We could just create an empty list and fill it in a loop.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>it

<span class="n">i_was_filled_in_a_loop</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">99995</span><span class="p">):</span> <span class="c1"># i ranges from 5 to 99994</span>
    <span class="n">i_was_filled_in_a_loop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">large_sequence</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8.16 ms ± 197 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</pre></div>
</div>
</div>
</div>
<p>But the more efficient way is to apply Python slicing:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">timeit</span> slice_of_it = large_sequence[5:99995]
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>256 µs ± 21 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</pre></div>
</div>
</div>
</div>
<p>or as,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">timeit</span> slice_of_it = large_sequence[5:-5]
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>276 µs ± 18 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</pre></div>
</div>
</div>
</div>
<p>Python slicing obviously executes faster. Try to avoid Python loops when you can slice instead.</p>
<p>When slicing as we did: <code class="docutils literal notranslate"><span class="pre">large_sequence[5:-5]</span></code>, we use Python slicing together with negative indexing. <code class="docutils literal notranslate"><span class="pre">5</span></code> stands for <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">-5</span></code> stands for <code class="docutils literal notranslate"><span class="pre">stop</span></code>. <code class="docutils literal notranslate"><span class="pre">step</span></code> is not specified, so it is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> implicitly. What if we do not specify <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">stop</span></code>, or if we even omit <em>any</em> indexing when slicing?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We now add a few elements to the a list for the</span>
<span class="c1"># sake of doing a demo.</span>
<span class="c1">#</span>
<span class="c1"># list.extend method differs from list.append.</span>
<span class="c1"># list.append adds an item as the last element</span>
<span class="c1"># of the list, while list.extend expects a se-</span>
<span class="c1"># quence as an argument and appends all its ele-</span>
<span class="c1"># ments to the list one by one.</span>
<span class="c1">#</span>
<span class="c1"># For more info:</span>
<span class="c1"># https://docs.python.org/3/tutorial/datastructures.html</span>
<span class="n">a</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;fourth&#39;</span><span class="p">,</span> <span class="s1">&#39;fifth&#39;</span><span class="p">,</span> <span class="s1">&#39;sixth&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;first&#39;, &#39;second&#39;, &#39;third&#39;, &#39;fourth&#39;, &#39;fifth&#39;, &#39;sixth&#39;]
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Slicing when <code class="docutils literal notranslate"><span class="pre">start</span></code> is omitted</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We pass few arguments to the print function.</span>
<span class="c1"># When they are outputted, they are separated by</span>
<span class="c1"># the value passed to the sep argument (its default</span>
<span class="c1"># value is set to &#39; &#39;).</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">a</span><span class="p">[:</span><span class="mi">5</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;first&#39;, &#39;second&#39;, &#39;third&#39;]
[&#39;first&#39;, &#39;second&#39;, &#39;third&#39;, &#39;fourth&#39;, &#39;fifth&#39;]
</pre></div>
</div>
</div>
</div>
<p>The output basically tells us that when <code class="docutils literal notranslate"><span class="pre">start</span></code> is omitted it is implicitly set to <code class="docutils literal notranslate"><span class="pre">0</span></code>. Slicing a sequence with <code class="docutils literal notranslate"><span class="pre">sequence[:n]</span></code> is equivalent to <em>extracting subsequence of first <span class="math notranslate nohighlight">\(n\)</span> elements</em>. It is important to keep in mind that the above statement concerns the case of <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. Consider the following example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;sixth&#39;, &#39;fifth&#39;]
</pre></div>
</div>
</div>
</div>
<p>Obviously, slicing in such a way is equivalent to doing <code class="docutils literal notranslate"><span class="pre">a[5:-3:-1]</span></code> or <code class="docutils literal notranslate"><span class="pre">a[-1:-3:-1]</span></code>. More generally, <code class="docutils literal notranslate"><span class="pre">sequence[:-n:-1]</span></code> is <em>extracting a subsequence consisting of the last <span class="math notranslate nohighlight">\(n-1\)</span> elements enumerated from the tail of the sequence</em>.</p>
<ul class="simple">
<li><p>Slicing when <code class="docutils literal notranslate"><span class="pre">stop</span></code> is omitted</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:],</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;third&#39;, &#39;fifth&#39;]
[&#39;sixth&#39;]
[&#39;fifth&#39;, &#39;fourth&#39;, &#39;third&#39;, &#39;second&#39;, &#39;first&#39;]
</pre></div>
</div>
</div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">stop</span></code> is omitted, <code class="docutils literal notranslate"><span class="pre">sequence[n::step]</span></code> for <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> extracts the relevant elements from index n up to (and including) the last element of the sequence. If the <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">sequence[n::step]</span></code> extracts the relevant elements from index n down to (and including) the first element of the sequence.</p>
<ul class="simple">
<li><p>Slicing when <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> are omitted</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[:],</span> <span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;first&#39;, &#39;second&#39;, &#39;third&#39;, &#39;fourth&#39;, &#39;fifth&#39;, &#39;sixth&#39;]
[&#39;first&#39;, &#39;third&#39;, &#39;fifth&#39;]
[&#39;sixth&#39;, &#39;fifth&#39;, &#39;fourth&#39;, &#39;third&#39;, &#39;second&#39;, &#39;first&#39;]
</pre></div>
</div>
</div>
</div>
<p>Let’s summarize our little tests by the exact citations taken from <a class="reference external" href="https://docs.python.org/dev/library/stdtypes.html#sequence-types-list-tuple-range">documentation</a>:</p>
<p>Consider the slice sequence <code class="docutils literal notranslate"><span class="pre">s</span></code> taken as follows: <code class="docutils literal notranslate"><span class="pre">s[i:j:k]</span></code>, then</p>
<blockquote>
<div><p>If <em>i</em> or <em>j</em> are omitted or <code class="docutils literal notranslate"><span class="pre">None</span></code>, they become “end” values (which end depends on the sign of <em>k</em>). Note, <em>k</em> cannot be zero. If <em>k</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, it is treated like <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</div></blockquote>
<p>That is pretty much what we’ve observed so far. We would comment on that <code class="docutils literal notranslate"><span class="pre">k</span></code> cannot be zero. This limitation implies that the implementation of this case raises an <a class="reference external" href="https://docs.python.org/3/tutorial/errors.html">exception</a> of type <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>. By default occurrences of uncaught exceptions terminate code execution. We won’t get into the details of the treatment of exceptions, but you can read about it on your own if you are interested.</p>
<p>We would also cite another important piece of documentation on sequences slicing:</p>
<blockquote>
<div><p>If <em>i</em> or <em>j</em> is greater than <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>, use <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>.</p>
</div></blockquote>
<p>What is so curious about it exactly? Consider the following examples:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="mi">1000</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">350</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;first&#39;, &#39;second&#39;, &#39;third&#39;, &#39;fourth&#39;, &#39;fifth&#39;, &#39;sixth&#39;]
[&#39;sixth&#39;, &#39;fifth&#39;, &#39;fourth&#39;, &#39;third&#39;, &#39;second&#39;, &#39;first&#39;]
</pre></div>
</div>
</div>
</div>
<p>Do you see the point now? <strong>Index overflow does not raise exception in Python slicing</strong>.</p>
<p>And another important property of slicing:</p>
<blockquote>
<div><p>If <em>i</em> is greater than or equal to <em>j</em>, the slice is empty.</p>
</div></blockquote>
<p>Note that this particular statement concerns the case of <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. Similarly, in the case <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, if <code class="docutils literal notranslate"><span class="pre">j</span></code> is greater than or equal to <code class="docutils literal notranslate"><span class="pre">i</span></code>, the slice is empty. Consider the demo:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[]
[]
[]
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="referenced-or-copied">
<h3><span class="section-number">1.3.2. </span>Referenced or copied?<a class="headerlink" href="#referenced-or-copied" title="Permalink to this headline">¶</a></h3>
<p>The important question to ask when you create one object from another in Python, is <em>whether I am copying or referencing it?</em> In other words, <em>does my old object get modified when I modify the new one?</em></p>
<p>This question is deeply rooted in the meaning of the <code class="docutils literal notranslate"><span class="pre">=</span></code> symbol in Python. In Python, the symbol <code class="docutils literal notranslate"><span class="pre">=</span></code> is used to <em>assign</em> the value on its right-hand side to the variable on the left-hand side.</p>
<p>When you write this very simple statement,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">=</span><span class="mi">1</span>
</pre></div>
</div>
<p>Python does two things:</p>
<ul class="simple">
<li><p>it creates an integer objects in memory containing the value 1</p></li>
<li><p>it attaches (assigns) the name <code class="docutils literal notranslate"><span class="pre">a</span></code> to this location in memory</p></li>
</ul>
<p>You have to remember that <code class="docutils literal notranslate"><span class="pre">a</span></code> is just a shortcut or name for the object containing the integer <span class="math notranslate nohighlight">\(1\)</span>. For numbers, this does not create much confusion. Consider for example the following lines of code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial value of b: </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Value of b after re-assignment: </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Value of a after re-assignment: </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initial value of b: 1
Value of b after re-assignment: 2
Value of a after re-assignment: 1
</pre></div>
</div>
</div>
</div>
<p>Things behave quite intuitively. For lists or arrays, one needs to pay special attention. Consider another example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial value of b: </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Value of b after re-assignment: </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Value of a after re-assignment: </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initial value of b: [0, 1, 2, 3]
Value of b after re-assignment: [5, 1, 2, 3]
Value of a after re-assignment: [5, 1, 2, 3]
</pre></div>
</div>
</div>
</div>
<p>Do you notice something intriguing? The content of the list <code class="docutils literal notranslate"><span class="pre">a</span></code> has been modified by the statement <code class="docutils literal notranslate"><span class="pre">b[0]=5</span></code>. Let’s discuss why this is so.</p>
<p>The first line of code creates 4 integer objects and a list object. It gives the name <code class="docutils literal notranslate"><span class="pre">a</span></code> to this list. <code class="docutils literal notranslate"><span class="pre">a[0],</span> <span class="pre">a[1],</span> <span class="pre">a[2],</span> <span class="pre">a[3]</span></code> are just shortcuts for the integer objects storing the values <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3</span></code>.</p>
<p>In the second line of code, we give another name to the list; we tell the code that <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are two different names pointing to the same list. <code class="docutils literal notranslate"><span class="pre">b[0],</span> <span class="pre">b[1],</span> <span class="pre">b[2],</span> <span class="pre">b[3]</span></code> are then names pointing to the same integer objects as <code class="docutils literal notranslate"><span class="pre">a[0],</span> <span class="pre">a[1],</span> <span class="pre">a[2],</span> <span class="pre">a[3]</span></code>. For that reason, the initial <code class="docutils literal notranslate"><span class="pre">print</span></code> statement outputs the content of the list <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>The statement <code class="docutils literal notranslate"><span class="pre">b[0]=5</span></code> then creates another integer object storing the value <span class="math notranslate nohighlight">\(5\)</span> and <code class="docutils literal notranslate"><span class="pre">b[0]</span></code> becomes a shortcut to this new object. The list <code class="docutils literal notranslate"><span class="pre">b</span></code> is obviously affected. But the system has been told that <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are nicknames for the same list. Note that we have not re-assigned <code class="docutils literal notranslate"><span class="pre">b</span></code> to another list, we have only changed the content of the list; this is allowed as a list in Python is mutable (you can change its content). So <code class="docutils literal notranslate"><span class="pre">a[0]</span></code> now also points to the integer object storing <span class="math notranslate nohighlight">\(5\)</span> and this explains the output produced by the last print statement.</p>
<p>If you really want to change the content of the list <code class="docutils literal notranslate"><span class="pre">b</span></code> without affecting <code class="docutils literal notranslate"><span class="pre">a</span></code>, you need to create a separate copy of <code class="docutils literal notranslate"><span class="pre">a</span></code> and give that copy the name <code class="docutils literal notranslate"><span class="pre">b</span></code>. This can be done as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial value of b: </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Value of b after re-assignment: </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Value of a after re-assignment: </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initial value of b: [0, 1, 2, 3]
Value of b after re-assignment: [5, 1, 2, 3]
Value of a after re-assignment: [0, 1, 2, 3]
</pre></div>
</div>
</div>
</div>
<p>Now you see that <code class="docutils literal notranslate"><span class="pre">b</span></code> has been modified while <code class="docutils literal notranslate"><span class="pre">a</span></code> is unchanged.</p>
<p>The whole discussion has been done using lists but the same behavior is true for <code class="docutils literal notranslate"><span class="pre">numpy.arrays</span></code>.</p>
<p>When it comes to slices, this translates to:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(n\)</span>-level-deep elements of the original sequence for <span class="math notranslate nohighlight">\(n=1\)</span> become copied in the slice</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span>-level-deep elements of the original sequence for <span class="math notranslate nohighlight">\(n&gt;1\)</span> are references in the slice</p></li>
</ul>
<p>First, let’s clarify what is meant by n level depth? Python sequences can have nested sequences, like in the following example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">i_have_nested_dict</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;hello&#39;</span><span class="p">:</span> <span class="s1">&#39;world&#39;</span><span class="p">}]</span>
</pre></div>
</div>
</div>
</div>
<p>We say that integers <span class="math notranslate nohighlight">\(1, 2\)</span> and <span class="math notranslate nohighlight">\(3\)</span> are one-level-deep in the sequence, keys and values of the nested <a class="reference external" href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">dictionary</a> <code class="docutils literal notranslate"><span class="pre">{'hello':</span> <span class="pre">'world'}</span></code> are then two-level-deep. Let’s first consider examples when there are no nested sequences in the outer sequence:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># First, we copy sequence a into the new variable</span>
<span class="c1"># to keep a itself in its original state.</span>
<span class="n">original</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">original</span><span class="p">[:]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;original sequence:&#39;</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">slice:&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="n">original</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">999</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">original sequence:&#39;</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">slice:&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">original sequence:&#39;</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">slice:&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>original sequence: [0, 1, 2, 3] 
slice: [0, 1, 2, 3]

original sequence: [999, 1, 2, 3] 
slice: [0, 1, 2, 3]

original sequence: [999, 1, 2, 3] 
slice: [0, False, 2, 3]
</pre></div>
</div>
</div>
</div>
<p>You can see that neither modifications made to the original sequence affect the slice, nor the modifications made to the slice affect the original sequence.</p>
<p>But what if there were a nested sequence?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">i_am_slice</span> <span class="o">=</span> <span class="n">i_have_nested_dict</span><span class="p">[:]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">original sequence:&#39;</span><span class="p">,</span> <span class="n">i_have_nested_dict</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">slice:&#39;</span><span class="p">,</span> <span class="n">i_am_slice</span><span class="p">)</span>

<span class="n">i_am_slice</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="s1">&#39;bye&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;world&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">original sequence:&#39;</span><span class="p">,</span> <span class="n">i_have_nested_dict</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">slice:&#39;</span><span class="p">,</span> <span class="n">i_am_slice</span><span class="p">)</span>

<span class="n">i_am_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9999999</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">original sequence:&#39;</span><span class="p">,</span> <span class="n">i_have_nested_dict</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">slice:&#39;</span><span class="p">,</span> <span class="n">i_am_slice</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>original sequence: [1, 2, 3, {&#39;hello&#39;: &#39;world&#39;}] 
slice: [1, 2, 3, {&#39;hello&#39;: &#39;world&#39;}]

original sequence: [1, 2, 3, {&#39;hello&#39;: &#39;world&#39;, &#39;bye&#39;: &#39;world&#39;}] 
slice: [1, 2, 3, {&#39;hello&#39;: &#39;world&#39;, &#39;bye&#39;: &#39;world&#39;}]

original sequence: [1, 2, 3, {&#39;hello&#39;: &#39;world&#39;, &#39;bye&#39;: &#39;world&#39;}] 
slice: [9999999, 2, 3, {&#39;hello&#39;: &#39;world&#39;, &#39;bye&#39;: &#39;world&#39;}]
</pre></div>
</div>
</div>
</div>
<p>We observe that while we change first-level-deep elements of the slice independently of those of the original sequence (<strong>because they have been copied into a different location in memory</strong>), the inner sequence is <strong>referenced - the slice just points to the location in memory where the original sequence stores it</strong>. In the example shown, we have added a new key-value pair in the dictionary.</p>
<p><strong>Deep</strong> and <strong>shallow</strong> copies are important concepts in Python.</p>
<p>When you create a shallow copy, you rather copy a structure of the original sequence than its content. The elements of the original sequence that are more than one level deep, get referenced, not copied.</p>
<p>Deep copy copies <strong>everything</strong>. Any level deep elements of the original sequenced are duplicated (stored in the separate place in memory).</p>
<p>When you program you must always be aware with which one you are operating.</p>
</div>
</div>
<div class="section" id="one-sided-finite-differences">
<h2><span class="section-number">1.4. </span>One-sided finite differences<a class="headerlink" href="#one-sided-finite-differences" title="Permalink to this headline">¶</a></h2>
<p>In section <a class="reference external" href="#First-order-derivative">First-order derivative</a> we mentioned that the finite difference expressions provided cannot be applied at all grid points. The centered finite difference formula is not valid at both endpoints of the domain as it requires at those locations extra points not included in the domain. At the left boundary - <span class="math notranslate nohighlight">\(x_0\)</span> - we could compute the first order derivative using the forward finite difference formula and at the right boundary - <span class="math notranslate nohighlight">\(x_n\)</span> - we could use the backward finite difference formula. Throughout the domain we would then have:</p>
<div class="math notranslate nohighlight">
\[\begin{split}    \begin{cases}
	&amp; \displaystyle f'(x_0) = \frac{f(x_{1}) - f(x_0)}{\Delta x}, \\
    &amp; \displaystyle f'(x_i) = \frac{f(x_{i+1}) - f(x_{i-1})}{2\Delta x},\; \; 1 \leq i \leq n-1 \\
	&amp; \displaystyle f'(x_n) = \frac{f(x_{n}) - f(x_{n-1})}{\Delta x}.
    \end{cases}\end{split}\]</div>
<p>The inconvenience of this formulation is that it is second-order accurate for interior grid points but only first-order accurate at boundary nodes. It might not seem a big issue, but for certain problems the overall accuracy of the solution will be first order throughout the domain and not second order as we might have wished. We will give an example of this behavior later on.</p>
<p>To improve our discretized operator, we have to find second-order accurate expressions for the boundary nodes and we can use Taylor’s theorem to achieve this goal. At the left boundary node we have:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
f(x_0 + \Delta x) = f(x_0) +f'(x_0)\Delta x+\frac12 f''(x_0)\Delta x^2+O(\Delta x^3)\\
f(x_0 + 2\Delta x) = f(x_0) +2f'(x_0)\Delta x+4\frac12 f''(x_0)\Delta x^2+O(\Delta x^3)
\end{align*}\]</div>
<p>If we multiply the first equation by two and then substract the second one, we get:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
4 f(x_0 + \Delta x) - f(x_0 + 2\Delta x) = 3 f(x_0) + 2f'(x_0)\Delta x + O(\Delta x^3)
\end{equation*}\]</div>
<p>We can then define the following second-order accurate approximation of <span class="math notranslate nohighlight">\(f'\)</span> at <span class="math notranslate nohighlight">\(x_0\)</span>:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
f'_0 = \frac{-\frac32 f_0 + 2f_1 - \frac12 f_2}{\Delta x}
\end{equation*}\]</div>
<p>The stencil for this expression is represented as:</p>
<a class="reference internal image-reference" href="../../../_images/onesideDiff1.png"><img alt="../../../_images/onesideDiff1.png" src="../../../_images/onesideDiff1.png" style="width: 600px;" /></a>
<p>Similarly, the following expression constitutes a second-order accurate approximation of <span class="math notranslate nohighlight">\(f'\)</span> at <span class="math notranslate nohighlight">\(x_n\)</span>,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
f'(x_n) = \frac{\frac32 f_n - 2f_{n-1} + \frac12 f_{n-2}}{\Delta x}
\end{equation*}\]</div>
<p>and its stencil is:</p>
<a class="reference internal image-reference" href="../../../_images/onesideDiff1_2.png"><img alt="../../../_images/onesideDiff1_2.png" src="../../../_images/onesideDiff1_2.png" style="width: 600px;" /></a>
<p>We can now construct a second-order discretized operator throughout the domain by using the above two expressions at the boundary nodes. Our complete computation of the second-order accurate first-order derivative then looks like (for the sake of completeness, we repeat the whole code here):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nx</span> <span class="o">=</span> <span class="mi">80</span>          <span class="c1"># number of grid points (coarse grid)</span>
<span class="n">lx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>       <span class="c1"># length of interval</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">lx</span> <span class="o">/</span> <span class="p">(</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># grid spacing</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lx</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>          <span class="c1"># coordinates in the coarse grid</span>
<span class="n">f_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x_c</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x_c</span><span class="p">)</span> <span class="c1"># function in the coarse grid</span>

<span class="n">df_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>

<span class="c1"># Here we take advantage of Python slicing instead</span>
<span class="c1"># of Python looping.</span>
<span class="n">df_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">f_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f_c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="o">*</span><span class="n">f_c</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx</span>
<span class="n">df_2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">f_c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">f_c</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="o">*</span><span class="n">f_c</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx</span>
<span class="n">df_2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_c</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">f_c</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="c1"># We only display x-axis starting from the minimum</span>
<span class="c1"># of sequence (x[0], x_c[0]) to the maximum of</span>
<span class="c1"># sequence (x[-1], x_c[-1]).</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dfdx</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Exact&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_c</span><span class="p">,</span> <span class="n">df_2</span><span class="p">,</span> <span class="s1">&#39;^g&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Approximated&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;$f&#39;$&quot;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/03_01_FirstOrderDerivative_and_Slicing_61_0.png" src="../../../_images/03_01_FirstOrderDerivative_and_Slicing_61_0.png" />
</div>
</div>
</div>
<div class="section" id="summary">
<h2><span class="section-number">1.5. </span>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>In this notebook, we learned how to approximate derivatives using finite differences. We illustrated how finite-difference formulas can be derived and showed how to treat boundary nodes in the numerical grid.</p>
<p>Besides that, we’ve explained the Python slicing and motivated its usage showing its advantage over Python looping. In the next notebook we extend our knowledge on finite differences by considering higher-order derivatives.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./solving_pde_mooc/notebooks/03_FiniteDifferences"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="../02_TimeIntegration/02_02_RungeKutta.html" title="previous page"><span class="section-number">2. </span>Runge-Kutta methods</a>
    <a class='right-next' id="next-link" href="03_02_HigherOrderDerivative_and_Functions.html" title="next page"><span class="section-number">2. </span>Higher order derivatives, functions and matrix formulation</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By B. Knaepen & Y. Velizhanina<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../../../_static/js/index.3da636dd464baa7582d2.js"></script>


    
  </body>
</html>