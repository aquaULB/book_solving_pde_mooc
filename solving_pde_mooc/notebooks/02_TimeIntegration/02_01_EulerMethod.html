

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>3. Euler methods &#8212; Solving Partial Differential Equations - MOOC</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=5b4479735964841361fd" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=5b4479735964841361fd" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mycss.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=5b4479735964841361fd" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd" />
  <script src="../../../_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=5b4479735964841361fd"></script>

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'solving_pde_mooc/notebooks/02_TimeIntegration/02_01_EulerMethod';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="4. Runge-Kutta methods" href="02_02_RungeKutta.html" />
    <link rel="prev" title="2. Approximations and Taylor expansion" href="../01_Introduction/01_02_TaylorExpansion.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../01_Introduction/01_00_Preface.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo.png" class="logo__image only-light" alt="Solving Partial Differential Equations - MOOC - Home"/>
    <script>document.write(`<img src="../../../_static/logo.png" class="logo__image only-dark" alt="Solving Partial Differential Equations - MOOC - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../01_Introduction/01_00_Preface.html">
                    Numerical methods for partial differential equations
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01_01_ToolkitSetup.html">1. Toolkit Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01_02_TaylorExpansion.html">2. Approximations and Taylor expansion</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Time integration</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">3. Euler methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_02_RungeKutta.html">4. Runge-Kutta methods</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Finite differences</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../03_FiniteDifferences/03_01_FirstOrderDerivative_and_Slicing.html">6. First-order derivative and slicing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_FiniteDifferences/03_02_HigherOrderDerivative_and_Functions.html">7. Higher order derivatives, functions and matrix formulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_FiniteDifferences/03_03_BoundaryValueProblems.html">8. Boundary value problems</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Partial differential equations</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../04_PartialDifferentialEquations/04_01_Advection.html">9. The first-order wave equation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_PartialDifferentialEquations/04_02_StabilityAnalysis.html">10. Matrix and modified wavenumber stability analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_PartialDifferentialEquations/04_03_Diffusion_Explicit.html">11. One dimensional heat equation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_PartialDifferentialEquations/04_04_Diffusion_Implicit.html">12. One dimensional heat equation: implicit methods</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Iterative methods</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../05_IterativeMethods/05_01_Iteration_and_2D.html">13. Iteration methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_IterativeMethods/05_02_Conjugate_Gradient.html">14. The conjugate gradient method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_IterativeMethods/05_03_Boosting_Python.html">15. Boosting Python</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/aquaULB/solving_pde_mooc" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/solving_pde_mooc/notebooks/02_TimeIntegration/02_01_EulerMethod.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Euler methods</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">3.1. Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-forward-euler-method">3.2. The forward Euler method</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#numerical-accuracy-of-the-forward-euler-method">3.2.1. Numerical accuracy of the forward Euler method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#numerical-stability-of-the-forward-euler-method">3.2.2. Numerical stability of the forward Euler method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#higher-order-example">3.2.3. Higher-order example</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#numerical-stability-of-the-forward-euler-method-revisited">3.2.4. Numerical stability of the forward Euler method revisited</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-backward-euler-method">3.3. The backward Euler method</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#summary">3.4. Summary</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="euler-methods">
<h1><span class="section-number">3. </span>Euler methods<a class="headerlink" href="#euler-methods" title="Permalink to this heading">#</a></h1>
<section id="introduction">
<h2><span class="section-number">3.1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">#</a></h2>
<p>In this part of the course we discuss how to solve ordinary differential equations (ODEs). Although their numerical resolution is not the main subject of this course, their study nevertheless allows to introduce very important concepts that are essential in the numerical resolution of partial differential equations (PDEs).</p>
<p>The ODEs we consider can be written in the form:</p>
<div class="math notranslate nohighlight" id="equation-eq-ode">
<span class="eqno">(4)<a class="headerlink" href="#equation-eq-ode" title="Permalink to this equation">#</a></span>\[  y^{(n)}=f(t, y, \dots, y^{(n-1)}),\]</div>
<p>where <span class="math notranslate nohighlight">\(y=y(t)\)</span> is a function of the variable <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(y^{(n)}\)</span> represents the n-th derivative of <span class="math notranslate nohighlight">\(y\)</span> with respect to <span class="math notranslate nohighlight">\(t\)</span>:</p>
<div class="math notranslate nohighlight">
\[  y^{(n)}=\frac{d^n y}{dt^n}.\]</div>
<p>When <span class="math notranslate nohighlight">\(f\)</span> does not depend explicitly on time, we qualify the problem as <em>autonomous</em>.</p>
<p>Note that we have used <span class="math notranslate nohighlight">\(t\)</span> as the variable on which the unknown function <span class="math notranslate nohighlight">\(y\)</span> depends and we will usually refer to it as <em>time</em>. However, all the methods we describe in this chapter also apply to other problems in which a given function depends on an independant variable and the corresponding ODE has the form <a class="reference internal" href="#equation-eq-ode">(4)</a>.</p>
<p>As an example and toy problem, let us consider radioactive decay. Imagine we have a sample of material containing <span class="math notranslate nohighlight">\(N\)</span> unstable nuclei at a given initial time <span class="math notranslate nohighlight">\(t_0\)</span>. The time evolution of <span class="math notranslate nohighlight">\(N\)</span> then follows an exponential decay law:</p>
<div class="math notranslate nohighlight" id="equation-eq-decay">
<span class="eqno">(5)<a class="headerlink" href="#equation-eq-decay" title="Permalink to this equation">#</a></span>\[  \frac{dN(t)}{dt}=-\alpha N(t).\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha&gt;0\)</span> is a constant depending on the type of nuclei present in the material. Of course, we don’t really need a computer to solve this equation as its solution is readily obtained and reads:</p>
<div class="math notranslate nohighlight" id="equation-eq-expdecay">
<span class="eqno">(6)<a class="headerlink" href="#equation-eq-expdecay" title="Permalink to this equation">#</a></span>\[  N(t)=N(t_0)e^{-\alpha t}\]</div>
<p>However, our objective here is to obtain the above time evolution using a numerical scheme.</p>
</section>
<section id="the-forward-euler-method">
<h2><span class="section-number">3.2. </span>The forward Euler method<a class="headerlink" href="#the-forward-euler-method" title="Permalink to this heading">#</a></h2>
<p>The most elementary time integration scheme - we also call these ‘time advancement schemes’ - is known as the forward (explicit) Euler method - it is actually member of the Euler family of numerical methods for ordinary differential equations. We use it to introduce several fundamental concepts that will pop up frequently in the rest of the course. This scheme is based on computing an approximation of the unknown function at time <span class="math notranslate nohighlight">\(t+dt\)</span> from its known value at time <span class="math notranslate nohighlight">\(t\)</span> using the Taylor expansion limited to the first two terms. We then have:</p>
<div class="math notranslate nohighlight" id="equation-eq-forwardeuler">
<span class="eqno">(7)<a class="headerlink" href="#equation-eq-forwardeuler" title="Permalink to this equation">#</a></span>\[N(t+dt) \equiv N(t) + N'(t)dt \;\;\;\; \textrm{Forward Euler method}\]</div>
<p>From this equation, we note that the forward Euler method is of second order for going from <span class="math notranslate nohighlight">\(t\)</span> to <span class="math notranslate nohighlight">\(t+dt\)</span> (the dropped term in the Taylor expansion is <span class="math notranslate nohighlight">\(O(dt^2)\)</span>). Once the value of <span class="math notranslate nohighlight">\(N\)</span> is known at time <span class="math notranslate nohighlight">\(t+dt\)</span>, one can re-use <a class="reference internal" href="#equation-eq-forwardeuler">(7)</a> to reach time <span class="math notranslate nohighlight">\(t+2dt\)</span> and so on.</p>
<p>Schematically, we therefore start the time marching procedure at the initial time <span class="math notranslate nohighlight">\(t_0\)</span> and make a number of steps (called time steps) of size <span class="math notranslate nohighlight">\(dt\)</span> until we reach the final desired time <span class="math notranslate nohighlight">\(t_f\)</span>. In order to do this, we need <span class="math notranslate nohighlight">\(n_t = (t_f - t_i)/dt\)</span> steps.</p>
<p>By convention, we denote the different intermediate times as <span class="math notranslate nohighlight">\(t^n = t_0+ndt\)</span> and the corresponding values of <span class="math notranslate nohighlight">\(N\)</span> as <span class="math notranslate nohighlight">\(N^n = N(t_0+ndt)\)</span> so that <span class="math notranslate nohighlight">\(N^n = N(t^n)\)</span>.</p>
<p>The forward Euler scheme is then alternatively written as:</p>
<div class="math notranslate nohighlight" id="equation-eq-forwardeuler2">
<span class="eqno">(8)<a class="headerlink" href="#equation-eq-forwardeuler2" title="Permalink to this equation">#</a></span>\[N^{n+1} \equiv N^n + N^{'n} dt \;\;\;\; \textrm{Forward Euler method}\]</div>
<p>Let’s write a Python code for that. First, we perform some imports.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<p>Now let’s set some constant parameters for our problem. In real-world codes, constant parameters are usually separated from the main code. They are either put in a separate module, or set in an inputfile. At this stage, let’s just isolate them in a separate cell.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="c1"># Exponential law coefficient</span>
<span class="n">ti</span> <span class="o">=</span> <span class="mf">0.0</span>     <span class="c1"># Initial time</span>
<span class="n">tf</span> <span class="o">=</span> <span class="mf">5.0</span>     <span class="c1"># Final time</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.5</span>     <span class="c1"># Time step</span>
<span class="n">Ni</span> <span class="o">=</span> <span class="mi">100</span>     <span class="c1"># Initial condition</span>
</pre></div>
</div>
</div>
</div>
<p>Now we can write a code for the actual numerical procedure.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># First, we compute the number of steps.</span>
<span class="c1"># Note that the number of steps must</span>
<span class="c1"># be an integer, but the time data</span>
<span class="c1"># we construct it from is of float type.</span>
<span class="c1"># We therefore need to use the int() function.</span>
<span class="c1"># It converts the input data to an</span>
<span class="c1"># integer. If a float is provided as an input,</span>
<span class="c1"># it disregards the decimals. For example,</span>
<span class="c1"># int(5.0/2.0) returns 2.</span>
<span class="n">nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">tf</span><span class="o">-</span><span class="n">ti</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>

<span class="c1"># Then we create an empty numpy array for</span>
<span class="c1"># the intermediate values of N, including</span>
<span class="c1"># those at ti and tf.</span>
<span class="c1">#</span>
<span class="c1"># You may wonder, how can a piece of numerical</span>
<span class="c1"># data be empty or not empty? But here</span>
<span class="c1"># it is rather a conventional term used</span>
<span class="c1"># to indicate that the values have not been</span>
<span class="c1"># initialized - set to 0. It means that they</span>
<span class="c1"># can have any value in a range allowed by the</span>
<span class="c1"># numerical precision. Initializing takes time so unless</span>
<span class="c1"># you need an array of zeros, np.empty is preferable</span>
<span class="c1"># over np.zeros.</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># We pass the initial condition to the N array,</span>
<span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ni</span>

<span class="c1"># and perform the time stepping:</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha</span><span class="o">*</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">dt</span>
</pre></div>
</div>
</div>
</div>
<p>Done! The last entry in the array N now contains an estimate for <span class="math notranslate nohighlight">\(N(t_f)\)</span>.</p>
<section id="numerical-accuracy-of-the-forward-euler-method">
<h3><span class="section-number">3.2.1. </span>Numerical accuracy of the forward Euler method<a class="headerlink" href="#numerical-accuracy-of-the-forward-euler-method" title="Permalink to this heading">#</a></h3>
<p>Let us compare graphically our numerical values with the exact solution <a class="reference internal" href="#equation-eq-expdecay">(6)</a>. For that purpose we use again the matplotlib package:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="o">%</span><span class="k">matplotlib</span> inline

<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;../styles/mainstyle.use&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># In this cell, we compute the</span>
<span class="c1"># exact solution of the differential</span>
<span class="c1"># equation.</span>
<span class="c1">#</span>
<span class="c1"># numpy.arange builds a sequence of numbers. It</span>
<span class="c1"># is similar to the Python&#39;s standard</span>
<span class="c1"># range function, BUT, unlike it, it can</span>
<span class="c1"># operate not only on integers, but also</span>
<span class="c1"># floats, and its return type is a numpy</span>
<span class="c1"># native array.</span>
<span class="c1">#</span>
<span class="c1"># For more info:</span>
<span class="c1"># https://numpy.org/doc/stable/reference/generated/numpy.arange.html</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>

<span class="c1"># We are all set to build the exact solution array.</span>
<span class="n">Nexact</span> <span class="o">=</span> <span class="n">Ni</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>When you’re <em>debugging</em> - developing, testing and optimizing your code, it is always a good idea to have your imports and setup of <em>constant parameters</em> separated from the code you’re working on. The same stands for the actual computations and visualization. Imaging, you build your arrays of data in the same cell as you plot it. You see a plot and you don’t like the font, you rerun the cell, and then you think that it might be a good idea to cut the x-axis, you rerun the cell again. In such a way, each time you update your plot, you will recompute absolutely the same numpy array. If the array takes a lot of time to compute, you will lose a lot of time. For small examples, this is <em>not catastrophic, but considered to be a poor organization of a code</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a figure with a single subplot</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

<span class="c1"># Plot the exact solution. Set the linestyle.</span>
<span class="c1"># Matplotlib supports multiple line- and</span>
<span class="c1"># markerstyles. For the linestyles see</span>
<span class="c1"># https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/linestyles.html</span>
<span class="c1"># For the markers see</span>
<span class="c1"># https://matplotlib.org/3.3.1/api/markers_api.html</span>
<span class="c1">#</span>
<span class="c1"># Note, though, that here we specify linestyle</span>
<span class="c1"># as &#39;-&#39; (equivalent to &#39;solid&#39;) for infor-</span>
<span class="c1"># mative purposes. Solid linestyle is the default one,</span>
<span class="c1"># so, if you remove the linestyle specification here,</span>
<span class="c1"># the plot won&#39;t change.</span>
<span class="c1">#</span>
<span class="c1"># We also assign a label to the curve. A label is</span>
<span class="c1"># a string, which we want to be displayed in a</span>
<span class="c1"># legend.</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Nexact</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Exact solution&#39;</span><span class="p">)</span>

<span class="c1"># Plot the approximate solution. You can see that</span>
<span class="c1"># here we specify the appearance of the markers</span>
<span class="c1"># without using the keyword &#39;marker&#39;. We let</span>
<span class="c1"># Python figure out which argument we are setting</span>
<span class="c1"># by its position. There are POSITIONAL and</span>
<span class="c1"># KEYWORD arguments in Python functions. Posi-</span>
<span class="c1"># tional arguments must obey a certain order, so</span>
<span class="c1"># that it is clear which of the parameters they</span>
<span class="c1"># stands for. Keyword arguments are passed with the keywords.</span>
<span class="c1"># For example, we can write color=&#39;green&#39;,</span>
<span class="c1"># where color is a keyword argument. Sometimes</span>
<span class="c1"># keyword arguments can be passed as positional ones</span>
<span class="c1"># if you follow the E X A C T order provided in the implemen-</span>
<span class="c1"># tation of a function.</span>

<span class="c1"># For more info</span>
<span class="c1"># https://problemsolvingwithpython.com/07-Functions-and-Modules/07.07-Positional-and-Keyword-Arguments/</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Forward Euler method&#39;</span><span class="p">)</span>

<span class="c1"># We set labels for the axes and a title for the subplot.</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$t$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$N$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Radioactive decay&#39;</span><span class="p">)</span>

<span class="c1"># Make the legend visible.</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="c1"># And we save the whole figure to the specified</span>
<span class="c1"># location in the default png format.</span>
<span class="c1"># If you don&#39;t put .png suffix, the plot will</span>
<span class="c1"># still be saved as a png image. The keyword argument</span>
<span class="c1"># dpi defines resolution of your image. It is lite-</span>
<span class="c1"># rally &#39;dots per image&#39; - 300 is good enough for</span>
<span class="c1"># a scientific paper, no need to go to extremes.</span>
<span class="c1">#</span>
<span class="c1"># Btw, as you&#39;ve saved your figure once, it is a good</span>
<span class="c1"># idea to comment the line, so that you don&#39;t save</span>
<span class="c1"># the same image over and over, unless you modify the</span>
<span class="c1"># plot.</span>
<span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;../figures/radioactiveDecay.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/fdfcadb6783be96deefac15ea57258fdad74201fad2be5c09f12a4e552a62d1a.png" src="../../../_images/fdfcadb6783be96deefac15ea57258fdad74201fad2be5c09f12a4e552a62d1a.png" />
</div>
</div>
<p>The agreement between the exact solution and the approximate one is rather good. However, it degrades with time. Why so? The answer, of course, comes from the error introduced by cutting the Taylor series in the definition of the forward Euler scheme, and we know things should improve if we reduce <span class="math notranslate nohighlight">\(dt\)</span> but this will come at the expense of increasing the total number of time steps and the computational cost. To get an idea about this, run the previous code with a smaller and smaller time step and see what happens to the curves.</p>
<p>To analyze this from the quantitative point of view, let us redo the computation using several values of <span class="math notranslate nohighlight">\(dt\)</span> and compare the error made in estimating <span class="math notranslate nohighlight">\(N(t_f)\)</span>. In the following piece of code, we only store the value of <span class="math notranslate nohighlight">\(N\)</span> at <span class="math notranslate nohighlight">\(t_f\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a list containing the set of</span>
<span class="c1"># time steps, so that each time step is one half</span>
<span class="c1"># of the previous one.</span>
<span class="n">dt_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)])</span>

<span class="c1"># Create an array to store the values of</span>
<span class="c1"># N(tf) for the different time steps.</span>
<span class="c1"># numpy.empty_like returns the array with</span>
<span class="c1"># values non-initialized, just like numpy.empty,</span>
<span class="c1"># but, unlike numpy.empty, it takes as a para-</span>
<span class="c1"># meter not an integer, but either a sequence,</span>
<span class="c1"># or a numpy array - array-like in the termi-</span>
<span class="c1"># nology of numpy. The output array will have</span>
<span class="c1"># the same shape and type as an input data.</span>
<span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">dt_list</span><span class="p">)</span>

<span class="c1"># Now we want to loop over all values in</span>
<span class="c1"># dt_list. We also want to count our itera-</span>
<span class="c1"># tions, as if we were extracting indices of</span>
<span class="c1"># the elements of dt_list. We could create some</span>
<span class="c1"># variable i=0 (indexing in Python and most of</span>
<span class="c1"># the others programming languages starts with</span>
<span class="c1"># 0), and then increase it by 1 at each iteration,</span>
<span class="c1"># like this:</span>
<span class="c1">#</span>
<span class="c1"># i = 0</span>
<span class="c1"># for dt in dt_list:</span>
<span class="c1">#    (do something...)</span>
<span class="c1">#    i += 1</span>
<span class="c1">#</span>
<span class="c1"># But the moral here is WHY BOTHER. In this case,</span>
<span class="c1"># and in many others, Python developers already</span>
<span class="c1"># have implemented what we need: the enumerate fun-</span>
<span class="c1"># ction. It counts the elements in an iterable object</span>
<span class="c1"># and returns the counter at each iteration.</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dt_list</span><span class="p">):</span>
    <span class="c1"># Copy initial condition into the variable,</span>
    <span class="c1"># which we are going to advance for each size</span>
    <span class="c1"># of dt.</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">Ni</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">tf</span><span class="o">-</span><span class="n">ti</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>

    <span class="c1"># Be careful not to shadow the variables of</span>
    <span class="c1"># the exterior loop - i and dt - with the</span>
    <span class="c1"># variables of the interior loop. We set it</span>
    <span class="c1"># to be j.</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">alpha</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">dt</span>

    <span class="c1"># Save the final N to the values array</span>
    <span class="c1"># at the end of each time marching</span>
    <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s now compute and plot the difference between all the computed <span class="math notranslate nohighlight">\(N(t_f)\)</span> and the exact solution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We construct the array containing the differences</span>
<span class="c1"># between approximated and exact final solutions</span>
<span class="c1"># for each size of time step considered in dt_list.</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">values</span><span class="o">-</span><span class="n">Ni</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">tf</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

<span class="c1"># Plot the error in logarithmic scale and see</span>
<span class="c1"># that it grows as time step increases.</span>
<span class="n">ax</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">dt_list</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Error&#39;</span><span class="p">)</span>

<span class="c1"># Fit a slope to the previous curve and see</span>
<span class="c1"># that as they are parallel, the error after</span>
<span class="c1"># nt time steps is proportional to dt (not dt**2).</span>
<span class="n">ax</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">dt_list</span><span class="p">,</span> <span class="n">dt_list</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$dt$&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$dt$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Accuracy&#39;</span><span class="p">)</span>

<span class="c1"># Add a legend to the plot. Note how we added a semi-</span>
<span class="c1"># colon at the end of the statement. This removes an</span>
<span class="c1"># unnecessary ipython output just below the cell.</span>
<span class="c1"># Remove it and see the difference.</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>

<span class="c1"># fig.savefig(&#39;../figures/eulerSlope.png&#39;, dpi=300)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/9efea29c518756014356561e76a8611ea59a9e996ebcbd086ca8dedc9ea7dd10.png" src="../../../_images/9efea29c518756014356561e76a8611ea59a9e996ebcbd086ca8dedc9ea7dd10.png" />
</div>
</div>
<p>Do you notice something ‘surprising’ in this plot? Earlier we mentioned an accuracy of second order for the forward Euler method but here we observe an accuracy of first order. In fact, there is a straightforward explanation for this. We said “…that the forward Euler method is of second order for going from <span class="math notranslate nohighlight">\(t\)</span> to <span class="math notranslate nohighlight">\(t+dt\)</span>”. Here we are comparing values after <span class="math notranslate nohighlight">\(N\)</span> time steps with <span class="math notranslate nohighlight">\(\displaystyle N=\frac{t_f-t_i}{dt}\)</span>. The total error is proportional to the product of the error made at each time step multiplied by the number of steps. As the latter scales as <span class="math notranslate nohighlight">\(dt^{-1}\)</span>, the total error scales like <span class="math notranslate nohighlight">\(dt^2 / dt = dt\)</span>. One says that <strong>the error made during one time step accumulates during the computation</strong>.</p>
</section>
<section id="numerical-stability-of-the-forward-euler-method">
<h3><span class="section-number">3.2.2. </span>Numerical stability of the forward Euler method<a class="headerlink" href="#numerical-stability-of-the-forward-euler-method" title="Permalink to this heading">#</a></h3>
<p>For the radioactive decay equation, the forward Euler method does a decent job: when reducing the time step, the solution converges to the exact solution, albeit only with first-order accuracy. Let us now focus on another crucial property of numerical schemes called <em>numerical stability</em>.</p>
<p>For the problem of radioactive decay, we first observe that according to equation <a class="reference internal" href="#equation-eq-forwardeuler2">(8)</a> we have:</p>
<div class="math notranslate nohighlight" id="equation-eq-demo-stability">
<span class="eqno">(9)<a class="headerlink" href="#equation-eq-demo-stability" title="Permalink to this equation">#</a></span>\[    N^{n} = (1-\alpha dt)N^{n-1}  = (1-\alpha dt)^2 N^{n-2}= \dots = (1-\alpha dt)^{n}N_{0}\]</div>
<p>Equation <a class="reference internal" href="#equation-eq-demo-stability">(9)</a> implies that <span class="math notranslate nohighlight">\(N^n\to \infty\)</span> if <span class="math notranslate nohighlight">\(\vert 1-\alpha dt \vert^n \to \infty\)</span>. In such a case the numerical scheme is called <em>unstable</em> - i.e when solution grows unbounded (blows up in the jargon). On the other hand, in the case <span class="math notranslate nohighlight">\(\vert 1-\alpha dt \vert \le 1\)</span>, the Euler scheme is said to be stable. This requirement limits the time step allowed when performing the numerical integration.</p>
<p>In many problems, the coefficients of the equations are complex (e.g. Schrödinger equation). If we generalize our radioactive decay problem to allow for complex valued coefficients,</p>
<div class="math notranslate nohighlight">
\[ \frac{dy}{dt} = \lambda y\]</div>
<p>with <span class="math notranslate nohighlight">\(\lambda=\lambda_r + i\lambda_i\)</span>, the criteria for stability of the forward Euler scheme becomes,</p>
<div class="math notranslate nohighlight" id="equation-eq-complex-stability">
<span class="eqno">(10)<a class="headerlink" href="#equation-eq-complex-stability" title="Permalink to this equation">#</a></span>\[  \vert 1+\lambda dt \vert \le 1 \Leftrightarrow (1+\lambda_rdt)^2+(\lambda_idt)^2 \le 1.\]</div>
<p>Given this, one can then draw a stability diagram indicating the region of the complex plane <span class="math notranslate nohighlight">\((\lambda_rdt , \lambda_idt)\)</span>, where the forward Euler scheme is stable. From <a class="reference internal" href="#equation-eq-complex-stability">(10)</a>, we conclude that the bounded region of stability <em>is a circle</em> centered around <span class="math notranslate nohighlight">\((-1,0)\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s configure the size of the figure</span>
<span class="c1"># (in inches) to make it a square and bigger.</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># We draw a circle and customize it a bit. You</span>
<span class="c1"># can see that because of some reason the fun-</span>
<span class="c1"># ction name here starts with a capital letter -</span>
<span class="c1"># Circle. That&#39;s because matplotlib.pyplot.Circle</span>
<span class="c1"># is not really a function. It is an object called a</span>
<span class="c1"># c l a s s in Python. We won&#39;t dig into classes</span>
<span class="c1"># at this stage, but what it means for us here?</span>
<span class="c1"># Well, when we call the class by its name, we</span>
<span class="c1"># are actually calling its c o n s t r u c t o r -</span>
<span class="c1"># in-class function (method), which returns an</span>
<span class="c1"># i n s t a n c e of the class.</span>
<span class="c1"># In this way, we have the instance of a class -</span>
<span class="c1"># circle, which we have to add to the subplot</span>
<span class="c1"># somehow. Otherwise, the figure and circle are</span>
<span class="c1"># fully separated from each other, circle s t a n d s</span>
<span class="c1"># a l o n e from the whole drawing.</span>
<span class="c1">#</span>
<span class="c1"># For more info on the Circle class</span>
<span class="c1"># https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.patches.Circle.html</span>
<span class="n">circle</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>

<span class="c1"># There is a method of the Axes object, which is res-</span>
<span class="c1"># ponsible for exactly what we need - adding</span>
<span class="c1"># an Artist object to the plots. Yes, Circle ori-</span>
<span class="c1"># ginates from another generic object - Artist.</span>
<span class="c1"># Generally speaking, most of drawable objects in</span>
<span class="c1"># Matplotlib originate from the Artist class. So, if we</span>
<span class="c1"># wanted to go exotic, we could even have added</span>
<span class="c1"># our lines through add_artist, instead of using</span>
<span class="c1"># plot.</span>
<span class="c1">#</span>
<span class="c1"># For more info</span>
<span class="c1"># https://matplotlib.org/3.1.1/api/artist_api.html#matplotlib.artist.Artist</span>
<span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>

<span class="c1"># We make sure that the scaling for the x-axis</span>
<span class="c1"># is the same as for the y_axis.</span>
<span class="c1">#</span>
<span class="c1"># For more info</span>
<span class="c1"># https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.axes.Axes.set_aspect.html</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># We move the axes drawn on the left and</span>
<span class="c1"># on the bottom of the subplot to the center,</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
<span class="c1"># And hide the pieces of the subplot&#39;s frame</span>
<span class="c1"># which are on the right and on top.</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># See that Python&#39;s syntax allows creation</span>
<span class="c1"># of few variables at a time.</span>
<span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">2.3</span>
<span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xmin</span> <span class="p">,</span><span class="n">xmax</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>

<span class="c1"># Let&#39;s complement our plot with arrows. We won&#39;t</span>
<span class="c1"># dig into details of how arrows are configured, as</span>
<span class="c1"># you already have enough knowledge to figure it out</span>
<span class="c1"># yourself.</span>
<span class="c1">#</span>
<span class="c1"># For more info</span>
<span class="c1"># https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.arrow.html</span>
<span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
         <span class="n">head_width</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mf">20.</span><span class="o">*</span><span class="p">(</span><span class="n">ymax</span><span class="o">-</span><span class="n">ymin</span><span class="p">),</span> <span class="n">head_length</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mf">20.</span><span class="o">*</span><span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">),</span>
         <span class="n">overhang</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">length_includes_head</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">clip_on</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">ymax</span><span class="o">-</span><span class="n">ymin</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
         <span class="n">head_width</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mf">20.</span><span class="o">*</span><span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">),</span> <span class="n">head_length</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mf">20.</span><span class="o">*</span><span class="p">(</span><span class="n">ymax</span><span class="o">-</span><span class="n">ymin</span><span class="p">),</span>
         <span class="n">overhang</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">length_includes_head</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">clip_on</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

<span class="c1"># Let&#39;s set location for the axes labels, and</span>
<span class="c1"># change the orientation of the label of the y-</span>
<span class="c1"># axis - by default it is 90.</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\lambda_r dt$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\lambda_i dt$&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_label_coords</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_label_coords</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mf">0.475</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Stability of forward Euler scheme&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">1.01</span><span class="p">)</span>

<span class="c1"># Let&#39;s configure the ticks of the axes. The</span>
<span class="c1"># most straightforward way of doing it is to</span>
<span class="c1"># pass locations of the ticks explicitly.</span>
<span class="c1">#</span>
<span class="c1"># You also can pass the ticklabels you want</span>
<span class="c1"># using set_ticklabels method.</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">((</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># Consider these 2 commented lines of code.</span>
<span class="c1"># When cutomizing axes&#39; ticks, Matplotlib pro-</span>
<span class="c1"># vides Locator and Formatter objects - you</span>
<span class="c1"># can customize the ticks in basically one</span>
<span class="c1"># simple call without accessing the ticklabels</span>
<span class="c1"># data.</span>
<span class="c1">#</span>
<span class="c1"># For more info</span>
<span class="c1"># https://jakevdp.github.io/PythonDataScienceHandbook/04.10-customizing-ticks.html</span>
<span class="c1">#</span>
<span class="c1"># ax.xaxis.set_major_locator(plt.MaxNLocator(2))</span>
<span class="c1"># ax.yaxis.set_major_locator(plt.MaxNLocator(4))</span>

<span class="c1"># Though, sometimes, Locator will not be as</span>
<span class="c1"># flexible as you need it to be. For example,</span>
<span class="c1"># imagine that here, on top of hiding some ticks,</span>
<span class="c1"># we also want to hide some specific tick - with</span>
<span class="c1"># a zero label. Consider the following way of</span>
<span class="c1"># doing it - by accessing indices of ticks in</span>
<span class="c1"># a tuple* returned by the get_ticklabels function,</span>
<span class="c1"># and checking if it satisfies a certain condition.</span>
<span class="c1"># Such a method is certainly not as graceful as</span>
<span class="c1"># the one which goes with Locators, but it is</span>
<span class="c1"># quite u n i v e r s a l.</span>
<span class="c1">#</span>
<span class="c1"># *tuple in Python is a standard type of sequence,</span>
<span class="c1"># which, unlike a regular sequence, is unchangable.</span>

<span class="c1"># for i, label in enumerate(ax.yaxis.get_ticklabels()):</span>
<span class="c1">#     if i % 2 != 0 or i == 4:</span>
<span class="c1">#         label.set_visible(False)</span>

<span class="c1"># As the width of the axes became twice wider,</span>
<span class="c1"># after drawing the arrows, let&#39;s adjust the width</span>
<span class="c1"># of the ticks.</span>
<span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># fig.savefig(&#39;../figures/eulerStabilityMap.png&#39;, dpi=300)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/c2f2e3d3160dffc3970466448a9539667fe9671edbaed9c9c821954e7ef3bef5.png" src="../../../_images/c2f2e3d3160dffc3970466448a9539667fe9671edbaed9c9c821954e7ef3bef5.png" />
</div>
</div>
<p>If <span class="math notranslate nohighlight">\(dt\)</span> is chosen sufficiently small, so that both <span class="math notranslate nohighlight">\(\alpha_rdt\)</span> and <span class="math notranslate nohighlight">\(\alpha_i dt\)</span> are inside a circle, then the forward Euler scheme will be stable. We see in particular that the forward Euler scheme cannot be made stable if <span class="math notranslate nohighlight">\(\alpha\)</span> is purely imaginary, however small we choose the time step (we will consider a consequence of this below).</p>
</section>
<section id="higher-order-example">
<h3><span class="section-number">3.2.3. </span>Higher-order example<a class="headerlink" href="#higher-order-example" title="Permalink to this heading">#</a></h3>
<p>So far we have only considered a simple one-dimensional example. In practice, many problems are modelled with coupled variables, making the corresponding equation multi-dimensional. Multi-dimensional equations also arise when the starting equations contain higher-order derivatives. They can then be converted to a system of first-order differential equations. Consider the scalar third-order differential equation for <span class="math notranslate nohighlight">\(y=y(x)\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq-high-order-eq">
<span class="eqno">(11)<a class="headerlink" href="#equation-eq-high-order-eq" title="Permalink to this equation">#</a></span>\[    \frac{d^3 y(x)}{dx^3} = f(y, x).\]</div>
<p>Let us introduce new variables:</p>
<div class="math notranslate nohighlight">
\[\begin{split}    &amp; y_0 = y(x), \\
    &amp; y_1 = \frac{d y(x)}{dx}, \\
    &amp; y_2 = \frac{d^2 y(x)}{dx^2}, \\
    &amp; y_3 = \frac{d^3 y(x)}{dx^3}.\end{split}\]</div>
<p>Equation <a class="reference internal" href="#equation-eq-high-order-eq">(11)</a> then transforms into a system of 3 first-order differential equations:</p>
<div class="math notranslate nohighlight">
\[\begin{split}    \begin{cases}
    &amp; \displaystyle\frac{d y_0}{dx} = y_1, \\
    &amp; \displaystyle\frac{d y_1}{dx} = y_2, \\
    &amp; \displaystyle\frac{d y_2}{dx} = f(y, x).
    \end{cases}\end{split}\]</div>
<p>This procedure is generic. Consider the down-to-earth example of the equation of motion for a body in free fall:</p>
<div class="math notranslate nohighlight">
\[    \frac{d^2 h}{d t^2}=-g,\]</div>
<p>where <span class="math notranslate nohighlight">\(g\)</span> is the acceleration due to gravity and <span class="math notranslate nohighlight">\(h\)</span> is the height of the object with respect to the ground.</p>
<p>We introduce the new variable <span class="math notranslate nohighlight">\(\displaystyle v = \frac{dh}{dt}\)</span>, which has the physical meaning of velocity, and obtain a system of 2 first-order differential equations:</p>
<div class="math notranslate nohighlight">
\[\begin{split}    \begin{cases}
    &amp; \displaystyle \frac{dh}{dt}=v,\\
    &amp; \displaystyle \frac{dv}{dt}=-g.
    \end{cases}\end{split}\]</div>
<p>If we apply the forward Euler scheme to this system, we get:</p>
<div class="math notranslate nohighlight">
\[\begin{split}    &amp; h^{n+1}=h^n + v^n dt,\\
    &amp; v^{n+1}=v^n  - g dt.\end{split}\]</div>
<p>We can also write the system of equation in matrix form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    h^{n+1} \\
    v^{n+1}
\end{pmatrix}
=
\begin{pmatrix}
    h^{n} \\
    v^{n}
\end{pmatrix}
+&amp;
\begin{pmatrix}
    0 &amp; 1 \\
    0 &amp; 0
\end{pmatrix}
\begin{pmatrix}
    h^{n} \\
    v^{n}
\end{pmatrix}
dt
+
\begin{pmatrix}
    0 \\
    -g
\end{pmatrix}
dt \\
&amp;\Leftrightarrow \nonumber \\
y^{n+1} &amp;= y^n + Ly^n dt + bdt\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(y=(h\;\; v)\)</span>, <span class="math notranslate nohighlight">\(b=(0\;\; -g)\)</span> and</p>
<div class="math notranslate nohighlight">
\[\begin{split}L=
\begin{pmatrix}
    0 &amp; 1 \\
    0 &amp; 0
\end{pmatrix}\end{split}\]</div>
<p>Let’s solve this system numerically and use numpy array functionalities to write our solution in a more compact way. As initial condition, we choose <span class="math notranslate nohighlight">\(h_0=100\,\textrm{m}\)</span> and <span class="math notranslate nohighlight">\(v_0=0\,\textrm{m/s}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>  <span class="c1"># ms^-2, gravitational constant</span>
<span class="n">h0</span> <span class="o">=</span> <span class="mf">100.</span> <span class="c1"># initial height</span>
<span class="n">v0</span> <span class="o">=</span> <span class="mf">0.</span>   <span class="c1"># initial velocity</span>

<span class="n">ti</span> <span class="o">=</span> <span class="mf">0.</span>   <span class="c1"># initial time</span>
<span class="n">tf</span> <span class="o">=</span> <span class="mf">4.0</span>  <span class="c1"># final time at which to seek the solution</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># time step</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">tf</span><span class="o">-</span><span class="n">ti</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>

<span class="c1"># We create a numpy array to contain the</span>
<span class="c1"># intermediate values of y, including</span>
<span class="c1"># those at ti and tf.</span>
<span class="c1"># You can see that, instead of passing</span>
<span class="c1"># a single integer to numpy.empty,</span>
<span class="c1"># we pass a tuple of two integers.</span>
<span class="c1"># This is a way to create 2D numpy arrays.</span>
<span class="c1">#</span>
<span class="c1"># The first integer defines the number of rows in</span>
<span class="c1"># the array, while the second integer defines</span>
<span class="c1"># the number of columns (in obvious analogy with</span>
<span class="c1"># matrices, BUT it&#39;s better not to call numpy</span>
<span class="c1"># array matrices, as there are also</span>
<span class="c1"># n u m e r i c a l objects in numpy called</span>
<span class="c1"># matrices and they differ. And to be honest,</span>
<span class="c1"># they don&#39;t bring anything extra - numpy developers in-</span>
<span class="c1"># tend to deprecate them.).</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="c1"># Store initial the condition h0, v0 in the first</span>
<span class="c1"># row of the array.</span>
<span class="c1">#</span>
<span class="c1"># Here some words about array indexing must be</span>
<span class="c1"># said. The right way to index a 1D array is</span>
<span class="c1"># to pass a single integer to it. It is</span>
<span class="c1"># a bit more complicated with 2D arrays. The gene-</span>
<span class="c1"># ric way to go, which always works, is to pass</span>
<span class="c1"># 2 integer numbers. The first one denotes the index</span>
<span class="c1"># of a row, and the second - the index of a co-</span>
<span class="c1"># lumn. But numpy developers implemented ways to</span>
<span class="c1"># easen the life of programmers. Below you see</span>
<span class="c1"># one of the examples. When you pass s i n g l e</span>
<span class="c1"># index to the numpy array, it is being interpreted</span>
<span class="c1"># as a row index. In this way you access a l l</span>
<span class="c1"># the columns in the first row, which spares you the nece-</span>
<span class="c1"># ssity to loop over all of them (in the chapter on finite</span>
<span class="c1"># differences, we&#39;ll also introduce the notion of slicing</span>
<span class="c1"># which allows to access the different elements of arrays</span>
<span class="c1"># in many different ways).</span>
<span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h0</span><span class="p">,</span> <span class="n">v0</span>

<span class="c1"># Create the vector b.</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="n">g</span><span class="p">])</span>

<span class="c1"># Create the matrix L. Note that the default type of</span>
<span class="c1"># values in a numpy array is double</span>
<span class="c1"># precision. So, it does not make a</span>
<span class="c1"># difference if you pass elements as</span>
<span class="c1"># reals (by putting floating point) or</span>
<span class="c1"># integers. We prefer it like that to be 100%</span>
<span class="c1"># explicit. But after all, it is rather a per-</span>
<span class="c1"># sonal choice.</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>

<span class="c1"># Perform the time stepping. numpy.dot is a</span>
<span class="c1"># very useful function providing various func-</span>
<span class="c1"># tionality. It can do vector product, matrix</span>
<span class="c1"># multiplication, sum product over axes. You</span>
<span class="c1"># will always have to take care of compatibi-</span>
<span class="c1"># lity of the shapes of input data.</span>
<span class="c1">#</span>
<span class="c1"># For more info</span>
<span class="c1"># https://numpy.org/doc/stable/reference/generated/numpy.dot.html</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">dt</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">dt</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s now display our results graphically.</p>
<p>We shall also demonstrate an interesting feature of <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>. We will create multiple subplots and store all of them in <em>one variable</em>. One could expect that this variable is some standard Python sequence (like tuple or list). But in the reality it will have the type <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>. Why is this so curious? Because this happens <strong>even if <code class="docutils literal notranslate"><span class="pre">numpy</span></code> is not imported</strong>. As <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> <a class="reference external" href="https://matplotlib.org/tutorials/introductory/pyplot.html">developers claim</a>:</p>
<blockquote>
<div><p>If matplotlib were limited to working with lists, it would be fairly useless for numeric processing. Generally, you will use numpy arrays. In fact, all sequences are converted to numpy arrays internally. The example below illustrates plotting several lines with different format styles in one function call using arrays.</p>
</div></blockquote>
<p>Indeed, we already spoke of the fact that <em>numpy arrays are faster than lists</em>. But let’s get back to our plot.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s create some sample array which</span>
<span class="c1"># will store the discrete time data for nt</span>
<span class="c1"># time steps.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="c1"># We, of course, now access different sub-</span>
<span class="c1"># plots as the elements of a numpy array.</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;-k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>

<span class="c1"># Here we limit the x-axis strictly to</span>
<span class="c1"># the domain in which t is defined, and</span>
<span class="c1"># demonstrate a VERY IMPORTANT FEATURE OF</span>
<span class="c1"># SEQUENCES IN PYTHON. It is the possi-</span>
<span class="c1"># bility of negative indexing, which is</span>
<span class="c1"># absent in many other programming langu-</span>
<span class="c1"># ages. When the a negative index is</span>
<span class="c1"># provided to a sequence in Python, then</span>
<span class="c1"># the element returned is &#39;counted&#39; from the end</span>
<span class="c1"># of the array. t[-1] refers to the last</span>
<span class="c1"># element of t. The logic behind this is that</span>
<span class="c1"># t[0] corresponds to the first element of the</span>
<span class="c1"># array so that going on step back brings you to</span>
<span class="c1"># the end of the array in a cyclic fashion.</span>
<span class="c1"># This is a very useful feature, which</span>
<span class="c1"># spares you the necessity to even care</span>
<span class="c1"># about how many elements your sequence</span>
<span class="c1"># contains.</span>
<span class="c1">#</span>
<span class="c1"># For more info</span>
<span class="c1"># http://wordaligned.org/articles/negative-sequence-indices-in-python</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$t$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$v$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Speed vs time (m/s)&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;-k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$t$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$h$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Height vs time (m)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.0, &#39;Height vs time (m)&#39;)
</pre></div>
</div>
<img alt="../../../_images/4b5d69ecd966b6ef2a1e2b0b9dcd60e84760f9e11ec4b20d663255ffbe975d89.png" src="../../../_images/4b5d69ecd966b6ef2a1e2b0b9dcd60e84760f9e11ec4b20d663255ffbe975d89.png" />
</div>
</div>
<p>In the above plots we have explicitly changed our usual plotting style: we used a thin black line. We do so to show you how to set those two parameters but for nearly all our plots we rely on our matplotlib style file. We advise you to do the same to keep the appearance of your plots consistent. But feel free to edit any style file according to your taste!</p>
</section>
<section id="numerical-stability-of-the-forward-euler-method-revisited">
<h3><span class="section-number">3.2.4. </span>Numerical stability of the forward Euler method revisited<a class="headerlink" href="#numerical-stability-of-the-forward-euler-method-revisited" title="Permalink to this heading">#</a></h3>
<p>Let’s consider another two dimensional example and analyze the motion of an object attached to a spring. The equation of motion reads:</p>
<div class="math notranslate nohighlight" id="equation-eq-spring">
<span class="eqno">(12)<a class="headerlink" href="#equation-eq-spring" title="Permalink to this equation">#</a></span>\[    m\frac{d^2 x}{d t^2}=-kx,\]</div>
<p>where <span class="math notranslate nohighlight">\(x\)</span> is the position of the object with respect to its equilibrium position and <span class="math notranslate nohighlight">\(k&gt;0\)</span> is the spring constant. Introducing the velocity <span class="math notranslate nohighlight">\(v=dx/dt\)</span>, this equation is equivalent to the following system:</p>
<div class="math notranslate nohighlight">
\[\begin{split}    &amp; \frac{dx}{dt}=v,\\
    &amp; \frac{dv}{dt}=-\gamma^2 x,\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(\gamma =\sqrt{k/m}\)</span>.</p>
<p>For the forward Euler scheme we have:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    x^{n+1} \\
    v^{n+1}
\end{pmatrix}
=
\begin{pmatrix}
    x^{n} \\
    v^{n}
\end{pmatrix}
+&amp;
\begin{pmatrix}
    0 &amp; 1 \\
    -\gamma^2 &amp; 0
\end{pmatrix}
\begin{pmatrix}
    x^{n} \\
    v^{n}
\end{pmatrix}
dt\end{split}\]</div>
<p>It does not seem very different from the previous problem so let’s implement this.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="mf">2.</span>    <span class="c1"># spring constant</span>
<span class="n">m</span> <span class="o">=</span> <span class="mf">1.</span>    <span class="c1"># object&#39;s mass</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">0.75</span> <span class="c1"># initial position</span>
<span class="n">v0</span> <span class="o">=</span> <span class="mf">0.</span>   <span class="c1"># initial velocity</span>
<span class="n">ti</span> <span class="o">=</span> <span class="mf">0.</span>   <span class="c1"># initial time</span>
<span class="n">tf</span> <span class="o">=</span> <span class="mf">40.0</span> <span class="c1"># final time at which the solution is computed</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.15</span> <span class="c1"># time step</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s first compute gamma and the number</span>
<span class="c1"># of time steps.</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="o">/</span><span class="n">m</span><span class="p">)</span>
<span class="n">nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">tf</span><span class="o">-</span><span class="n">ti</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>

<span class="c1"># Create a numpy array containing the</span>
<span class="c1"># intermediate values of y, including</span>
<span class="c1"># those at ti and tf.</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="c1"># Store initial condition in the first row</span>
<span class="c1"># of y.</span>
<span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span><span class="p">,</span> <span class="n">v0</span>

<span class="c1"># Create matrix L.</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">gamma</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>

<span class="c1"># Perform the time stepping.</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">dt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Store nt time steps.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$t$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$v$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Speed vs time (m/s)&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$t$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Position vs time (m)&#39;</span><span class="p">)</span>

<span class="c1"># Here we take advantage of that we</span>
<span class="c1"># store both axes objects in one vari-</span>
<span class="c1"># ables - we don&#39;t have to restrict the</span>
<span class="c1"># limits for each of them separately,</span>
<span class="c1"># as we can iterate over the members</span>
<span class="c1"># of the sequence - makes the code shorter.</span>
<span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">ax</span><span class="p">:</span>
    <span class="n">axis</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">40.</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/66fa52d9f0ed9d8343b2a89517fb728eecad3323e5bf00716945927ac56334b7.png" src="../../../_images/66fa52d9f0ed9d8343b2a89517fb728eecad3323e5bf00716945927ac56334b7.png" />
</div>
</div>
<p>Do you see something strange? We know that a frictionless harmonic oscillator, like the one we are considering, must oscillate back and forth with a constant amplitude. So, what exactly went wrong?</p>
<p>Let’s inspect the forward Euler scheme stability for the system we are solving. In order to decouple equations for <span class="math notranslate nohighlight">\(x^{n+1}\)</span> and <span class="math notranslate nohighlight">\(v^{n+1}\)</span>, we compute the eigenvalues <span class="math notranslate nohighlight">\(\lambda_i\)</span> and eigenvectors <span class="math notranslate nohighlight">\(v_i\)</span> of the matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}L=
\begin{pmatrix}
    0 &amp; 1 \\
    -\gamma^2 &amp; 0
\end{pmatrix},\end{split}\]</div>
<p>and get:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\lambda_1 = i\gamma,\;\; \lambda_2=-i\gamma,\;\;
v_1 =
\begin{pmatrix}
    1 \\
    i\gamma
\end{pmatrix},
\;\;
v_2 =
\begin{pmatrix}
    1 \\
    -i\gamma
\end{pmatrix}.\end{split}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(L\)</span> can then be decomposed as,</p>
<div class="math notranslate nohighlight">
\[\begin{split}L=Q\Lambda Q^{-1}\; \hbox{with,} \;\;
\Lambda =
\begin{pmatrix}
    i\gamma &amp; 0 \\
    0 &amp; -i\gamma
\end{pmatrix} \;\; \hbox{and} \;\;
Q=
\begin{pmatrix}
   1 &amp; 1 \\
    i\gamma &amp; -i\gamma
\end{pmatrix}.\end{split}\]</div>
<p>Using the vector notation <span class="math notranslate nohighlight">\(y=(x\;\; v)\)</span>, we can then reformulate our time advancement scheme as,</p>
<div class="math notranslate nohighlight" id="equation-eq-eigencoor">
<span class="eqno">(13)<a class="headerlink" href="#equation-eq-eigencoor" title="Permalink to this equation">#</a></span>\[\begin{split}y^{n+1} = y^{n}+ Ly^{n}dt\;\; &amp; \Leftrightarrow \;\; Q^{-1}y^{n+1} = Q^{-1}y^{n} + Q^{-1}Ly^{n}dt \\
&amp; \Leftrightarrow \;\; z^{n+1} = z^{n} + \Lambda z^{n}dt.\end{split}\]</div>
<p>In the last equation, <span class="math notranslate nohighlight">\(z=(z_1\;\; z_2)\)</span> are the coordinates in the eigenvector basis <span class="math notranslate nohighlight">\(y=z_1(t) v_1 + z_2(t) v_2\)</span>. In this basis, the system of equation is decoupled and reads:</p>
<div class="math notranslate nohighlight">
\[\begin{split}    &amp; z_1^{n+1} = z_1^{n} + i\gamma z_1^{n} dt\\
    &amp; z_2^{n+1} = z_2^{n} - i\gamma z_2^{n} dt\end{split}\]</div>
<p>It is now clear why the forward Euler scheme displays the diverging behaviour observed in the plots. The coefficients present in the advancement scheme are both purely imaginery and we have seen above that their product with <span class="math notranslate nohighlight">\(dt\)</span> necessarily lies outside of the domain of stability of the scheme. Therefore, we cannot avoid the divergence of our solution by taking even a very small time step. The forward Euler scheme is, therefore, not adapted to the simulation of a simple harmonic oscillator.</p>
</section>
</section>
<section id="the-backward-euler-method">
<h2><span class="section-number">3.3. </span>The backward Euler method<a class="headerlink" href="#the-backward-euler-method" title="Permalink to this heading">#</a></h2>
<p>The explicit Euler method gives a decent approximation in certain cases (<a class="reference internal" href="#equation-eq-decay">(5)</a>), but it is absolutely inapplicable in others since it blows up for <em>any</em> time step (<a class="reference internal" href="#equation-eq-spring">(12)</a>). It urges us to search for different ways to approximate evolution equations. One of them is the <em>implicit</em> Euler method.</p>
<p>Similarly to the explicit Euler method which is also referred to as the forward Euler method, the implicit Euler method is sometimes called the backward Euler method. Generally speaking, the difference between explicit and implicit numerical schemes is that in the first case the solution at latter point of the dependant variable (at a later time, for example) is built from the solution computed at the previous points; in the second case, the algorithm involves <em>both</em> the solution previous points and later points. Schematically we have:</p>
<div class="math notranslate nohighlight">
\[\begin{split}&amp; y^{n+1}(t) = f\Big(y^n, y^{n-1}, \ldots, y^0\Big),\;\; &amp; \hbox{Explicit scheme}, \\
&amp; g\Big(y^{n+1}, y^n, y^{n-1}, \ldots, y^0 \Big) = 0,\;\; &amp; \hbox{Implicit scheme}.\end{split}\]</div>
<p>The time advancement with the implicit Euler scheme is as follows:</p>
<div class="math notranslate nohighlight">
\[y^{n+1} = y^n + dt f(y^{n+1}, t^{n+1}).\]</div>
<p>The advantage of implicit schemes over explicit ones is that usually they allow a larger time step to be stable. They are then useful when dealing with a <em>stiff</em> problem. The problem is called stiff if its solution varies rapidly in time, so that certain numerical schemes require an extremely small time step for stability.</p>
<p>We computed the region of stability of the explicit Euler for linear autonomous homogeneous problems, like radioactive decay <a class="reference internal" href="#equation-eq-decay">(5)</a> or the movement of a mass attached to a spring <a class="reference internal" href="#equation-eq-spring">(12)</a>. Let’s compare the situation when using the implicit Euler for both of them.</p>
<p>We first consider radioactive decay <a class="reference internal" href="#equation-eq-decay">(5)</a>. The one-step advancement is given by:</p>
<div class="math notranslate nohighlight">
\[N^{n+1} = (1+\alpha dt)^{-1}N^n.\]</div>
<p>Let’s solve the equation for some input parameters and visualize the solution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We redefine all the constants. Even though</span>
<span class="c1"># they were defined in the above cell, some</span>
<span class="c1"># got overwritten when solving other problems.</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="c1"># Exponential law coeffecient</span>
<span class="n">ti</span> <span class="o">=</span> <span class="mf">0.0</span>     <span class="c1"># Initial time</span>
<span class="n">tf</span> <span class="o">=</span> <span class="mf">15.0</span>    <span class="c1"># Final time</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">1.</span>      <span class="c1"># Time step</span>
<span class="n">Ni</span> <span class="o">=</span> <span class="mi">100</span>     <span class="c1"># Initial condition</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">tf</span><span class="o">-</span><span class="n">ti</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>

<span class="c1"># Let us also redefine the array storing N, so that it contains</span>
<span class="c1"># both the solution predicted by the</span>
<span class="c1"># implicit and explicit schemes in two columns.</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="c1"># We copy initial condition into both columns.</span>
<span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ni</span><span class="p">,</span> <span class="n">Ni</span>

<span class="c1"># Define one-time step advancement coefficient</span>
<span class="c1"># assumed by the implicit Euler outside of the</span>
<span class="c1"># loop, as it is independant of t.</span>
<span class="c1"># If some computation is independant of the iteration index,</span>
<span class="c1"># try to ALWAYS take it out of the loop. Otherwise,</span>
<span class="c1"># you are performing useless repetitive computations,</span>
<span class="c1"># and simply waste time.</span>
<span class="n">coef_imp</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">alpha</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Advance solution both with the implicit and</span>
<span class="c1"># explicit schemes.</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha</span><span class="o">*</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dt</span>

    <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coef_imp</span><span class="o">*</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># t and Nexact have to be recomputed, as we</span>
<span class="c1"># have a newly defined tf.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>

<span class="n">Nexact</span> <span class="o">=</span> <span class="n">Ni</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Nexact</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Exact solution&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">N</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Forward Euler method&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">N</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Backward Euler method&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># We set labels for the axes and title of a subplot.</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$t$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$N$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Radioactive decay&#39;</span><span class="p">)</span>

<span class="c1"># Make the legend visible.</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/d39349dd0ad6180164392a0451d135d5f91f4b6d28cc50fe6b394eca904f1879.png" src="../../../_images/d39349dd0ad6180164392a0451d135d5f91f4b6d28cc50fe6b394eca904f1879.png" />
</div>
</div>
<p>Here we observe some interesting things. The solutions predicted by the explicit and implicit Euler schemes differ noticably. Even though they are both of the same order of accuracy, they are obviously not identical and the implicit Euler scheme matches the exact solution a bit better. Also, for the chosen time step, both methods are stable in this case.</p>
<p>Let us now go back to the equation <a class="reference internal" href="#equation-eq-spring">(12)</a>. We have proved that the forward Euler method is unstable for this case. Let us now check what happens with the backward Euler method.</p>
<p>For this problem, the scheme reads:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    x^{n+1} \\
    v^{n+1}
\end{pmatrix}
=
\begin{pmatrix}
    x^{n} \\
    v^{n}
\end{pmatrix}
+&amp;
\begin{pmatrix}
    0 &amp; 1 \\
    -\gamma^2 &amp; 0
\end{pmatrix}
\begin{pmatrix}
    x^{n+1} \\
    v^{n+1}
\end{pmatrix}
dt.\end{split}\]</div>
<p>After a little rearrangement:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
1 &amp; -dt\\
\gamma^2 dt &amp; 1
\end{pmatrix}
\begin{pmatrix}
    x^{n+1} \\
    v^{n+1}
\end{pmatrix}
= \begin{pmatrix}
    x^{n} \\
    v^{n}
\end{pmatrix},\end{split}\]</div>
<p>and finally:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    x^{n+1} \\
    v^{n+1}
\end{pmatrix}
= \begin{pmatrix}
1 &amp; -dt\\
\gamma^2 dt &amp; 1
\end{pmatrix}^{-1}
\begin{pmatrix}
    x^{n} \\
    v^{n}
\end{pmatrix}.\end{split}\]</div>
<p>Let’s implement this method in a code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We have to redefine time parameters</span>
<span class="c1"># again, as they got overwritten.</span>
<span class="n">ti</span> <span class="o">=</span> <span class="mf">0.</span>    <span class="c1"># initial time</span>
<span class="n">tf</span> <span class="o">=</span> <span class="mf">40.0</span>  <span class="c1"># final time at which the solution is computed</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.15</span>  <span class="c1"># time step</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Recompute the number of time steps and</span>
<span class="c1"># the time array.</span>
<span class="n">nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">tf</span><span class="o">-</span><span class="n">ti</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y_imp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="c1"># Store initial condition in the first row</span>
<span class="c1"># of y.</span>
<span class="n">y_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span><span class="p">,</span> <span class="n">v0</span>

<span class="c1"># As the matrix that advances the solution</span>
<span class="c1"># does not depend on t, we compute it</span>
<span class="c1"># right away.</span>
<span class="c1"># To do this, we use the linalg.inv function of numpy.</span>
<span class="c1">#</span>
<span class="c1"># For more info</span>
<span class="c1"># https://numpy.org/doc/stable/reference/generated/numpy.linalg.inv.html</span>
<span class="n">L_imp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="p">],</span> <span class="p">[</span><span class="n">gamma</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]))</span>

<span class="c1"># Perform the time stepping. dt is hidden</span>
<span class="c1"># in L_imp, so it does appear here.</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="n">y_imp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L_imp</span><span class="p">,</span> <span class="n">y_imp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y_imp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Backward Euler&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Forward Euler&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$t$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$v$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Speed vs time (m/s)&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y_imp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Backward Euler&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Forward Euler&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$t$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Position vs time (m)&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">ax</span><span class="p">:</span>
    <span class="n">axis</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
    <span class="n">axis</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">axis</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper center&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/29654b7851ff2dd7362f77610556ce00ac28709144b7e5da5bdf8153ff70c088.png" src="../../../_images/29654b7851ff2dd7362f77610556ce00ac28709144b7e5da5bdf8153ff70c088.png" />
</div>
</div>
<p>Obviously, the implicit Euler method does not blow up, but the solution is damped quickly. This a consequence of the numerical error being accumulated after <span class="math notranslate nohighlight">\(N\)</span> time steps and the large <span class="math notranslate nohighlight">\(dt\)</span> used.</p>
<p>Let’s compute the region of stability of the implicit Euler scheme.</p>
<p>The problem we are solving can be written as follows:</p>
<div class="math notranslate nohighlight" id="equation-eq-generic">
<span class="eqno">(14)<a class="headerlink" href="#equation-eq-generic" title="Permalink to this equation">#</a></span>\[y^{n+1} = \sigma y^{n} = \sigma^{n+1} y^{0}.\]</div>
<p>In the case of the implicit Euler scheme we have:</p>
<div class="math notranslate nohighlight" id="equation-eq-back-stab-sigma">
<span class="eqno">(15)<a class="headerlink" href="#equation-eq-back-stab-sigma" title="Permalink to this equation">#</a></span>\[\sigma = (1-\lambda dt)^{-1} = (1-\lambda_r dt - i\lambda_i dt)^{-1}.\]</div>
<p>We can write the denominator of <a class="reference internal" href="#equation-eq-back-stab-sigma">(15)</a> in a trigonometric form:</p>
<div class="math notranslate nohighlight">
\[\sigma = Ae^{i\phi},\]</div>
<p>where <span class="math notranslate nohighlight">\(A = 1/r = ((1-\lambda_r dt)^2 + \lambda_i^2 dt^2)^{-1/2}\)</span>.</p>
<p>Stability then requires:</p>
<div class="math notranslate nohighlight" id="equation-eq-back-stab">
<span class="eqno">(16)<a class="headerlink" href="#equation-eq-back-stab" title="Permalink to this equation">#</a></span>\[\vert \sigma \vert = A\vert e^{i\phi} \vert = A \le 1 \Rightarrow (1-\lambda_r dt)^2 + \lambda_i^2 dt^2 \ge 1.\]</div>
<p>Condition <a class="reference internal" href="#equation-eq-back-stab">(16)</a> implies that the region of stability of the implicit Euler is <em>outside</em> of the circle of radius 1 centered at <span class="math notranslate nohighlight">\(\lambda_r dt=1\)</span> and <span class="math notranslate nohighlight">\(\lambda_i dt=0\)</span>, which is, obviously, an infinite domain.</p>
<p>In the literature you will often encounter the statement that <em>the implicit Euler scheme is unconditionally stable</em> for linear autonomous homogeneous problems. You might think that this contradicts <a class="reference internal" href="#equation-eq-back-stab">(16)</a>, but in fact, when stating so, people usually imply that <span class="math notranslate nohighlight">\(\lambda_r \le 0\)</span>, so that the equation <a class="reference internal" href="#equation-eq-generic">(14)</a> only admits decaying solutions.</p>
</section>
<section id="summary">
<h2><span class="section-number">3.4. </span>Summary<a class="headerlink" href="#summary" title="Permalink to this heading">#</a></h2>
<p>In this notebook we have described the forward and the backward Euler schemes, and how we can discretize an ordinary differential equation (or a system of ODEs) to compute the time evolution of the physical quantities under consideration.</p>
<p>We computed the accuracy of the Euler method, and introduced the concept of stability of a numerical scheme. The former results directly from the number of terms retained in the Taylor expansion of the variables, while the latter originates from the structure of the time advancement scheme and the eigenvalues of the rhs linear operator appearing in the discretized equations.</p>
<p>In the next notebook, we introduce some more efficient time advancement schemes which have both better accuracy and larger domains of stability. They are know as Runge-Kutta schemes and we will use them extensively when analyzing partial differential equations later on in the course.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./solving_pde_mooc/notebooks/02_TimeIntegration"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../01_Introduction/01_02_TaylorExpansion.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">2. </span>Approximations and Taylor expansion</p>
      </div>
    </a>
    <a class="right-next"
       href="02_02_RungeKutta.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">4. </span>Runge-Kutta methods</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">3.1. Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-forward-euler-method">3.2. The forward Euler method</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#numerical-accuracy-of-the-forward-euler-method">3.2.1. Numerical accuracy of the forward Euler method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#numerical-stability-of-the-forward-euler-method">3.2.2. Numerical stability of the forward Euler method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#higher-order-example">3.2.3. Higher-order example</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#numerical-stability-of-the-forward-euler-method-revisited">3.2.4. Numerical stability of the forward Euler method revisited</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-backward-euler-method">3.3. The backward Euler method</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#summary">3.4. Summary</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By B. Knaepen & Y. Velizhanina
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=5b4479735964841361fd"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>